Require Import SyntaxProp.
Require Import StaticProp.
Require Import DynamicProp.
Require Import WellFormednessProp.

Require Import MapProp.

Hint Unfold subst.

Lemma type_preservation :
  forall id M M' H H' n n' e e' t,
    empty |- e \in t ->
    id / (M, H, n); e ==> (M', H', n'); e' ->
    empty |- e' \in t.
Proof with eauto using hasType_subst.
  introv hasType Hstep. gen e'.
  remember empty as Gamma.
  hasType_cases(induction hasType) Case; intros; inv Hstep;
  try solve[inv_ctx; constructors; eauto];
  try constructors.
  inv hasType1...
Qed.

Lemma wf_queue_preservation :
  forall id id' M M' H H' n n' e e' e'' l l' L L' C C' Q Q',
    id / (M, H, n); e ==> (M', H', n'); e' ->
    wf_cfg (M, H, n) ->
    wf_actor M H id (l, L, C, Q, e) ->
    (forall id a, heapLookup H id = Some a -> wf_actor M H id a) ->
    heapLookup H' id' = Some (l', L', C', Q', e'') ->
    wf_queue M' H' L' id' Q'.
Proof with eauto using is_econtext.
  introv Hstep wfCfg wfActor wfActors Hlookup.
  assert (id' < length H') as Hlt...
  inverts wfCfg as wfH wfM Mfresh Hfresh.
  assert (forall L'' l, LH H id' = Some L'' -> In l L'' -> In l L') as Hmono.
    introv HLH HIn. eapply monotonic_local_heap...
    unfolds LH; crush.
  gen e'. gen H.
  expr_cases (induction e) Case;
    intros; inv Hstep; simpls;
    try inv_ctx;
    try rewrite_and_invert...
  + Case "EApp". eapply wf_actor_ctx with (ctx := ctx_appl e2) in wfActor...
  + Case "EApp". eapply wf_actor_ctx with (ctx := ctx_appr e1) in wfActor...
  + Case "EApp". eapply wfActors in Hlookup... inv Hlookup...
  + Case "ESend". eapply wf_actor_ctx with (ctx := ctx_send v t e2) in wfActor...
  + Case "ESend". SCase "Actor regular".
    hauto.
    - eapply wfActors in H14 as wfActor'. inv wfActor'.
      eapply wf_queue_heapUpdate in H14...
      eapply wf_queue_snoc...
      inverts wfActor as [t hasType].
      constructors; simpls...
      ++ inv hasType...
      ++ inv hasType... introv contra.
         rewrite H23 in *. inv contra.
    - eapply wfActors in Hlookup as wfActor'.
      introv HIn.
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      eapply wfQueue in HIn as wfMsg.
      inverts wfMsg as Hex' Hloc' HId' HBId';
      constructors; hauto.
      introv HIn'. apply HBId' in HIn' as [Hlt' HBloc]. splits...
      hauto.
  + Case "ESend". SCase "Bestowed regular".
    hauto.
    - eapply wfActors in H14 as wfActor'. inv wfActor'.
      eapply wf_queue_heapUpdate in H14...
      eapply wf_queue_snoc...
      inverts wfActor as [t hasType].
      constructors; simpls...
      ++ inv hasType...
         eexists... repeat constructors...
         eapply hasType_subsumption...
         introv HIn.
         case_extend...
         eapply free_in_env in HIn as [t' contra]...
         rewrite extend_neq in contra...
         unfolds activeEnv... simpls...
      ++ inv hasType... introv HIn.
         rewrite H23 in HIn. simpls.
         inv HIn; try contradiction...
         specializes H26 l0 id' ___.
         inv H26 as (_ & Hloc).
         apply Hloc... hauto.
      ++ rewrite app_nil_r...
      ++ rewrite app_nil_r...
    - eapply wfActors in Hlookup.
      introv HIn.
      inv Hlookup...
      eapply H7 in HIn as wfMsg.
      inv wfMsg; constructors; hauto.
      introv HIn'. apply H3 in HIn' as [Hlt' HBloc]. splits...
      introv HLH. hauto.
  + Case "ESend". SCase "Actor atomic".
    eapply wfActors in Hlookup as wfActor'.
    inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
    introv HIn. eapply wfQueue in HIn as wfMsg.
    heap_case id id'.
    - inv wfMsg; try solve[constructors; eauto]...
      destruct (id_eq_dec qid qid0); subst;
        constructors; case_extend; try rewrite_and_invert...
    - inv wfMsg; try solve[constructors; eauto]...
      destruct (id_eq_dec qid qid0); subst;
        constructors; case_extend; try rewrite_and_invert...
  + Case "ESend". SCase "Bestowed atomic".
    eapply wfActors in Hlookup as wfActor'.
    inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
    introv HIn. eapply wfQueue in HIn as wfMsg.
    heap_case id id'.
    - inv wfMsg; try solve[constructors; eauto]...
      destruct (id_eq_dec qid qid0); subst;
        constructors; case_extend; try rewrite_and_invert...
    - inv wfMsg; try solve[constructors; eauto]...
      destruct (id_eq_dec qid qid0); subst;
        constructors; case_extend; try rewrite_and_invert...
  + Case "EMut".
    eapply wf_actor_ctx with (ctx := ctx_mut) in wfActor...
  + Case "EMut".
    apply wfActors in Hlookup... inv Hlookup...
  + Case "ENew".
    hauto.
    - eapply wfActors in H9 as wfActor'. inv wfActor'.
      eapply wf_queue_heapUpdate in H9...
      unfolds wf_queue.
      introv HIn. apply H7 in HIn as wfMsg.
      inv wfMsg; constructors; crush...
    - eapply wfActors in Hlookup. inv Hlookup.
      unfolds wf_queue. introv HIn.
      eapply H7 in HIn.
      inv HIn;
      constructors; hauto.
      introv HIn. eapply H3 in HIn as [Hlt' HBloc].
      splits...
      introv HLH. hauto.
      apply in_cons...
  + Case "ENew".
    eapply wf_actors_heapExtend in Hlookup...
    - inv Hlookup...
    - constructors; crush.
      * inv H0.
      * repeat constructors.
  + Case "EBes".
    eapply wf_actor_ctx in wfActor...
  + Case "EBes".
    apply wfActors in Hlookup... inv Hlookup...
  + Case "EAtStart".
    eapply wf_actor_ctx in wfActor...
  + Case "EAtStart". SCase "Actor success".
    hauto. (* Some of these cases can most likely be merged by being smarter about picking cases *)
    - introv HIn.
      eapply wfActors in H9 as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      eapply in_snoc in HIn. inv HIn.
      * eapply wfQueue in H0.
        inv H0; constructors; hauto...
        ++ introv HIn. eapply H4 in HIn as [Hlt' HBloc].
           splits...
           introv HLH. hauto.
        ++ assert (qid <> n)
               by (eapply Mfresh in H1; omega).
           case_extend...
      * constructors...
    - introv HIn.
      eapply wfActors in Hlookup as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      eapply wfQueue in HIn as wfMsg.
      inv wfMsg; constructors; hauto...
      * introv HIn'. eapply H3 in HIn' as [Hlt' HBloc].
         splits...
         introv HLH. hauto.
      * assert (qid <> n)
            by (eapply Mfresh in H0; omega).
         case_extend...
    - introv HIn.
      eapply wfActors in H12 as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      eapply in_snoc in HIn. inv HIn.
      * eapply wfQueue in H0 as wfMsg.
        inv wfMsg; constructors; hauto...
        ++ introv HIn'. eapply H4 in HIn' as [Hlt' HBloc].
           splits...
           introv HLH. hauto.
        ++ assert (qid <> n)
               by (eapply Mfresh in H1; omega).
           case_extend...
      * constructors...
    - introv HIn.
      eapply wfActors in H9 as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      eapply wfQueue in HIn as wfMsg.
      inv wfMsg; constructors; hauto...
      * introv HIn'. eapply H3 in HIn' as [Hlt' HBloc].
         splits...
         introv HLH. hauto.
      * assert (qid <> n)
            by (eapply Mfresh in H0; omega).
         case_extend...
    - introv HIn.
      eapply wfActors in Hlookup as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      eapply wfQueue in HIn as wfMsg.
      inv wfMsg; constructors; hauto...
      * introv HIn'. eapply H3 in HIn' as [Hlt' HBloc].
        splits...
        introv HLH. hauto.
      * assert (qid <> n)
            by (eapply Mfresh in H0; omega).
        case_extend...
  + Case "EAtStart". SCase "Bestowed success".
    hauto.
    - introv HIn.
      eapply wfActors in H9 as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      eapply in_snoc in HIn. inv HIn.
      * eapply wfQueue in H0.
        inv H0; constructors; hauto...
        ++ introv HIn. eapply H4 in HIn as [Hlt' HBloc].
           splits...
           introv HLH. hauto.
        ++ assert (qid <> n)
               by (eapply Mfresh in H1; omega).
           case_extend...
      * constructors...
    - introv HIn.
      eapply wfActors in Hlookup as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      eapply wfQueue in HIn as wfMsg.
      inv wfMsg; constructors; hauto...
      * introv HIn'. eapply H3 in HIn' as [Hlt' HBloc].
         splits...
         introv HLH. hauto.
      * assert (qid <> n)
            by (eapply Mfresh in H0; omega).
         case_extend...
    - introv HIn.
      eapply wfActors in H12 as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      eapply in_snoc in HIn. inv HIn.
      * eapply wfQueue in H0 as wfMsg.
        inv wfMsg; constructors; hauto...
        ++ introv HIn'. eapply H4 in HIn' as [Hlt' HBloc].
           splits...
           introv HLH. hauto.
        ++ assert (qid <> n)
               by (eapply Mfresh in H1; omega).
           case_extend...
      * constructors...
    - introv HIn.
      eapply wfActors in H9 as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      eapply wfQueue in HIn as wfMsg.
      inv wfMsg; constructors; hauto...
      * introv HIn'. eapply H3 in HIn' as [Hlt' HBloc].
         splits...
         introv HLH. hauto.
      * assert (qid <> n)
            by (eapply Mfresh in H0; omega).
         case_extend...
    - introv HIn.
      eapply wfActors in Hlookup as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      eapply wfQueue in HIn as wfMsg.
      inv wfMsg; constructors; hauto...
      * introv HIn'. eapply H3 in HIn' as [Hlt' HBloc].
        splits...
        introv HLH. hauto.
      * assert (qid <> n)
            by (eapply Mfresh in H0; omega).
        case_extend...
  + Case "EAtStart".
    eapply wfActors in Hlookup as wfActor'...
    inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
    introv HIn...
  + Case "EAtStart".
    eapply wfActors in Hlookup as wfActor'...
    inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
    introv HIn...
  + Case "EAtEnd".
    eapply wf_actor_ctx in wfActor...
  + Case "EAtEnd". SCase "Actor success".
    hauto.
    - eapply wfActors in H9 as wfActor'.
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      introv HIn. eapply wfQueue in HIn as wfMsg.
      inv wfMsg; constructors; hauto.
      * introv HIn'. eapply H3 in HIn' as [Hlt' HBloc].
        splits...
        introv HLH. hauto.
      * assert (qid0 <> n)
            by (eapply Mfresh in H0; omega).
        case_extend...
    - eapply wfActors in Hlookup as wfActor'.
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      introv HIn. eapply wfQueue in HIn as wfMsg.
      inv wfMsg; constructors; hauto.
      * introv HIn'. eapply H3 in HIn' as [Hlt' HBloc].
        splits...
        introv HLH. hauto.
      * assert (qid0 <> n)
            by (eapply Mfresh in H0; omega).
        case_extend...
  + Case "EAtEnd". SCase "Bestowed success".
    hauto.
    - eapply wfActors in H9 as wfActor'.
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      introv HIn. eapply wfQueue in HIn as wfMsg.
      inv wfMsg; constructors; hauto.
      * introv HIn'. eapply H3 in HIn' as [Hlt' HBloc].
        splits...
        introv HLH. hauto.
      * assert (qid0 <> n)
            by (eapply Mfresh in H0; omega).
        case_extend...
    - eapply wfActors in Hlookup as wfActor'.
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      introv HIn. eapply wfQueue in HIn as wfMsg.
      inv wfMsg; constructors; hauto.
      * introv HIn'. eapply H3 in HIn' as [Hlt' HBloc].
        splits...
        introv HLH. hauto.
      * assert (qid0 <> n)
            by (eapply Mfresh in H0; omega).
        case_extend...
  + Case "EAtEnd".
    eapply wfActors in Hlookup as wfActor'...
    inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
    introv HIn...
  + Case "EAtEnd".
    eapply wfActors in Hlookup as wfActor'...
    inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
    introv HIn...
Qed.

Lemma wf_actor_preservation :
  forall id id' M M' H H' n n' e e' e'' l l' L L' C C' Q Q',
    id / (M, H, n); e ==> (M', H', n'); e' ->
    wf_cfg (M, H, n) ->
    wf_actor M H id (l, L, C, Q, e) ->
    heapLookup H' id' = Some (l', L', C', Q', e'') ->
    wf_actor M' H' id' (l', L', C', Q', e'').
Proof with eauto using is_econtext.
  introv Hstep wfCfg wfActor Hlookup.
  inverts wfCfg as wfH wfM Mfresh Hfresh.
  inverts wfH as Hdisj Cdisj wfActors.
  gen e'. gen H.
  expr_cases (induction e) Case;
    intros; inv Hstep; simpls;
    try inv_ctx;
    try rewrite_and_invert...
  + Case "EApp". eapply wf_actor_ctx with (ctx := ctx_appl e2) in wfActor...
  + Case "EApp". eapply wf_actor_ctx with (ctx := ctx_appr e1) in wfActor...
  + Case "ESend". eapply wf_actor_ctx with (ctx := ctx_send v t e2) in wfActor...
  + Case "ESend". SCase "Actor regular".
    hauto.
    - eapply wfActors in H14 as wfActor'. inv wfActor'.
      constructors...
      * eapply wf_queue_heapUpdate...
        eapply wf_queue_snoc...
        inverts wfActor as [t hasType].
        constructors; simpls...
        ++ inv hasType...
        ++ inv hasType... introv HIn.
           rewrite H23 in HIn. inv HIn.
      * introv HIn. eapply in_snoc in HIn.
        inv HIn... congruence.
      * rewrite filter_snoc_false...
      * hauto.
      * introv HIn.
        eapply H16 in HIn as [Hlt' HBloc]...
        splits; hauto...
    - eapply wfActors in Hlookup as wfActor'. inv wfActor'.
      constructors...
      * eapply wf_queue_heapUpdate...
      * hauto.
      * introv HIn.
        eapply H16 in HIn as [Hlt' HBloc]...
        splits; hauto...
  + Case "ESend". SCase "Bestowed regular".
    hauto.
    - eapply wfActors in H14 as wfActor'. inv wfActor'.
      constructors...
      * eapply wf_queue_heapUpdate...
        eapply wf_queue_snoc...
        inverts wfActor as [t hasType].
        constructors; simpls...
        ++ inv hasType...
           repeat constructors...
           eapply hasType_subsumption...
           introv HIn. case_extend...
           eapply free_in_env with (x := 0) in H17 as [? contra]...
           unfold extend in contra.
           cases_if.
        ++ inv hasType... introv HIn.
           rewrite H23 in HIn. inv HIn; try contradiction.
           specializes H26 l0 id' ___. inv H26 as [_ HLH].
           hauto.
        ++ rewrite app_nil_r...
        ++ rewrite app_nil_r...
      * introv HIn. eapply in_snoc in HIn.
        inv HIn... congruence.
      * rewrite filter_snoc_false...
      * hauto.
      * introv HIn.
        eapply H16 in HIn as [Hlt' HBloc]...
        splits; hauto...
    - eapply wfActors in Hlookup as wfActor'. inv wfActor'.
      constructors...
      * eapply wf_queue_heapUpdate...
      * hauto.
      * introv HIn.
        eapply H16 in HIn as [Hlt' HBloc]...
        splits; hauto...
  + Case "ESend". SCase "Actor atomic".
    hauto.
    - eapply wfActors in Hlookup as wfActor'.
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      constructors...
      * introv HC.
        case_extend...
        eapply wfC in HC as []. rewrite_and_invert...
      * introv HIn.
        eapply wfQueue in HIn as wfMsg...
        inv wfMsg; try solve[constructors; eauto]...
        destruct (id_eq_dec qid qid0); subst;
        constructors; case_extend; try rewrite_and_invert...
  + Case "ESend". SCase "Bestowed atomic".
    hauto.
    - eapply wfActors in Hlookup as wfActor'.
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      constructors...
      * introv HC.
        case_extend...
        eapply wfC in HC as []. rewrite_and_invert...
      * introv HIn.
        eapply wfQueue in HIn as wfMsg...
        inv wfMsg; try solve[constructors; eauto]...
        destruct (id_eq_dec qid qid0); subst;
        constructors; case_extend; try rewrite_and_invert...
  + Case "EMut". eapply wf_actor_ctx in wfActor...
  + Case "ENew".
    hauto.
    - eapply wfActors in H9 as wfActor'.
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      constructors...
      * crush.
      * eapply wf_queue_heapUpdate...
        ++ introv HIn.
           eapply wfQueue in HIn as wfMsg.
           inv wfMsg;
             constructors...
           introv HIn'. eapply H1 in HIn'...
           apply in_cons...
        ++ crush.
      * crush.
      * hauto.
      * introv HIn.
        apply HBId in HIn as [id'' HLH].
        splits; hauto.
        introv HLH'. inv HLH'.
        apply in_cons...
    - eapply wfActors in Hlookup as wfActor'.
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      constructors...
      * eapply wf_queue_heapUpdate...
        crush.
      * hauto.
      * introv HIn.
        apply HBId in HIn as [id'' HLH].
        splits; hauto.
        introv HLH'. inv HLH'.
        apply in_cons...
  + Case "ENew".
    eapply wf_actors_heapExtend in Hlookup...
    constructors; crush.
    - inv H0.
    - repeat constructors...
  + Case "EBes". eapply wf_actor_ctx in wfActor...
  + Case "EAtStart". eapply wf_actor_ctx in wfActor...
  + Case "EAtStart". SCase "Actor success".
    hauto. (* Some of these cases can most likely be merged by being smarter about picking cases *)
    - eapply wfActors in H9 as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      constructors; hauto...
      * introv HC.
        unfold extend in HC.
        cases_if; try inv_eq...
        assert (qid <> n).
          eapply wfC in HC as [?Q contra].
          intros eq; subst...
          eapply Mfresh in contra; omega.
        case_extend...
      * introv HIn.
        eapply in_snoc in HIn. inv HIn; try constructors...
        eapply wfQueue in H0 as wfMsg.
        inv wfMsg; constructors; hauto...
        ++ introv HIn. eapply H4 in HIn as [Hlt HBloc].
           splits...
           introv HIn. hauto.
        ++ assert (qid <> n)
               by (eapply Mfresh in H1; omega).
           case_extend...
      * introv HIn.
        eapply in_snoc in HIn. inv HIn...
        congruence.
      * rewrite filter_snoc_true... eapply NoDup_snoc...
        introv contra. eapply filter_In in contra as [HIn _].
        eapply wfQueue in HIn as wfMsg. inv wfMsg.
        eapply Mfresh in H1. omega.
      * introv HIn. eapply HBId in HIn as [Hlt HBloc].
        splits...
        introv HLH. hauto.
    - eapply wfActors in Hlookup as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      constructors; hauto...
      * introv HC.
        assert (qid <> n).
          eapply wfC in HC as [?Q contra].
          intros eq; subst...
          eapply Mfresh in contra; omega.
        case_extend...
      * introv HIn.
        eapply wfQueue in HIn as wfMsg.
        inv wfMsg; constructors; hauto...
        ++ introv HIn'. eapply H3 in HIn' as [Hlt HBloc].
           splits...
           introv HIn'. hauto.
        ++ assert (qid <> n)
               by (eapply Mfresh in H0; omega).
           case_extend...
      * introv HIn. eapply HBId in HIn as [Hlt HBloc].
        splits...
        introv HLH. hauto.
    - eapply wfActors in H12 as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      constructors; hauto...
      * introv HC.
        assert (qid <> n).
          eapply wfC in HC as [?Q contra].
          intros eq; subst...
          eapply Mfresh in contra; omega.
        case_extend...
      * introv HIn.
        eapply in_snoc in HIn. inv HIn; try constructors...
        eapply wfQueue in H0 as wfMsg.
        inv wfMsg; constructors; hauto...
        ++ introv HIn. eapply H4 in HIn as [Hlt HBloc].
           splits...
           introv HIn. hauto.
        ++ assert (qid <> n)
               by (eapply Mfresh in H1; omega).
           case_extend...
      * introv HIn.
        eapply in_snoc in HIn. inv HIn...
        congruence.
      * rewrite filter_snoc_true... eapply NoDup_snoc...
        introv contra. eapply filter_In in contra as [HIn _].
        eapply wfQueue in HIn as wfMsg. inv wfMsg.
        eapply Mfresh in H1. omega.
      * introv HIn. eapply HBId in HIn as [Hlt HBloc].
        splits...
        introv HLH. hauto.
    - eapply wfActors in H9 as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      constructors; hauto...
      * introv HC.
        unfold extend in HC.
        cases_if; try inv_eq...
        assert (qid <> n).
          eapply wfC in HC as [?Q contra].
          intros eq; subst...
          eapply Mfresh in contra; omega.
        case_extend...
      * introv HIn.
        eapply wfQueue in HIn as wfMsg.
        inv wfMsg; constructors; hauto...
        ++ introv HIn'. eapply H3 in HIn' as [Hlt HBloc].
           splits...
           introv HIn'. hauto.
        ++ assert (qid <> n)
               by (eapply Mfresh in H0; omega).
           case_extend...
      * introv HIn. eapply HBId in HIn as [Hlt HBloc].
        splits...
        introv HLH. hauto.
    - eapply wfActors in Hlookup as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      constructors; hauto...
      * introv HC.
        assert (qid <> n).
          eapply wfC in HC as [?Q contra].
          intros eq; subst...
          eapply Mfresh in contra; omega.
        case_extend...
      * introv HIn.
        eapply wfQueue in HIn as wfMsg.
        inv wfMsg; constructors; hauto...
        ++ introv HIn'. eapply H3 in HIn' as [Hlt HBloc].
           splits...
           introv HIn'. hauto.
        ++ assert (qid <> n)
               by (eapply Mfresh in H0; omega).
           case_extend...
      * introv HIn. eapply HBId in HIn as [Hlt HBloc].
        splits...
        introv HLH. hauto.
  + Case "EAtStart".
    hauto. (* Some of these cases can most likely be merged by being smarter about picking cases *)
    - eapply wfActors in H9 as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      constructors; hauto...
      * introv HC.
        unfold extend in HC.
        cases_if; try inv_eq...
        assert (qid <> n).
          eapply wfC in HC as [?Q contra].
          intros eq; subst...
          eapply Mfresh in contra; omega.
        case_extend...
      * introv HIn.
        eapply in_snoc in HIn. inv HIn; try constructors...
        eapply wfQueue in H0 as wfMsg.
        inv wfMsg; constructors; hauto...
        ++ introv HIn. eapply H4 in HIn as [Hlt HBloc].
           splits...
           introv HIn. hauto.
        ++ assert (qid <> n)
               by (eapply Mfresh in H1; omega).
           case_extend...
      * introv HIn.
        eapply in_snoc in HIn. inv HIn...
        congruence.
      * rewrite filter_snoc_true... eapply NoDup_snoc...
        introv contra. eapply filter_In in contra as [HIn _].
        eapply wfQueue in HIn as wfMsg. inv wfMsg.
        eapply Mfresh in H1. omega.
      * introv HIn. eapply HBId in HIn as [Hlt HBloc].
        splits...
        introv HLH. hauto.
    - eapply wfActors in Hlookup as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      constructors; hauto...
      * introv HC.
        assert (qid <> n).
          eapply wfC in HC as [?Q contra].
          intros eq; subst...
          eapply Mfresh in contra; omega.
        case_extend...
      * introv HIn.
        eapply wfQueue in HIn as wfMsg.
        inv wfMsg; constructors; hauto...
        ++ introv HIn'. eapply H3 in HIn' as [Hlt HBloc].
           splits...
           introv HIn'. hauto.
        ++ assert (qid <> n)
               by (eapply Mfresh in H0; omega).
           case_extend...
      * introv HIn. eapply HBId in HIn as [Hlt HBloc].
        splits...
        introv HLH. hauto.
    - eapply wfActors in H12 as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      constructors; hauto...
      * introv HC.
        assert (qid <> n).
          eapply wfC in HC as [?Q contra].
          intros eq; subst...
          eapply Mfresh in contra; omega.
        case_extend...
      * introv HIn.
        eapply in_snoc in HIn. inv HIn; try constructors...
        eapply wfQueue in H0 as wfMsg.
        inv wfMsg; constructors; hauto...
        ++ introv HIn. eapply H4 in HIn as [Hlt HBloc].
           splits...
           introv HIn. hauto.
        ++ assert (qid <> n)
               by (eapply Mfresh in H1; omega).
           case_extend...
      * introv HIn.
        eapply in_snoc in HIn. inv HIn...
        congruence.
      * rewrite filter_snoc_true... eapply NoDup_snoc...
        introv contra. eapply filter_In in contra as [HIn _].
        eapply wfQueue in HIn as wfMsg. inv wfMsg.
        eapply Mfresh in H1. omega.
      * introv HIn. eapply HBId in HIn as [Hlt HBloc].
        splits...
        introv HLH. hauto.
    - eapply wfActors in H9 as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      constructors; hauto...
      * introv HC.
        unfold extend in HC.
        cases_if; try inv_eq...
        assert (qid <> n).
          eapply wfC in HC as [?Q contra].
          intros eq; subst...
          eapply Mfresh in contra; omega.
        case_extend...
      * introv HIn.
        eapply wfQueue in HIn as wfMsg.
        inv wfMsg; constructors; hauto...
        ++ introv HIn'. eapply H3 in HIn' as [Hlt HBloc].
           splits...
           introv HIn'. hauto.
        ++ assert (qid <> n)
               by (eapply Mfresh in H0; omega).
           case_extend...
      * introv HIn. eapply HBId in HIn as [Hlt HBloc].
        splits...
        introv HLH. hauto.
    - eapply wfActors in Hlookup as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      constructors; hauto...
      * introv HC.
        assert (qid <> n).
          eapply wfC in HC as [?Q contra].
          intros eq; subst...
          eapply Mfresh in contra; omega.
        case_extend...
      * introv HIn.
        eapply wfQueue in HIn as wfMsg.
        inv wfMsg; constructors; hauto...
        ++ introv HIn'. eapply H3 in HIn' as [Hlt HBloc].
           splits...
           introv HIn'. hauto.
        ++ assert (qid <> n)
               by (eapply Mfresh in H0; omega).
           case_extend...
      * introv HIn. eapply HBId in HIn as [Hlt HBloc].
        splits...
        introv HLH. hauto.
  + Case "EAtEnd". eapply wf_actor_ctx in wfActor...
  + Case "EAtEnd". SCase "Actor success".
    hauto.
    - eapply wfActors in H9 as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      constructors; hauto...
      * introv HC.
        unfold drop in HC.
        cases_if...
        assert (qid0 <> n).
          eapply wfC in HC as [?Q contra].
          intros eq; subst...
          eapply Mfresh in contra; omega.
        case_extend...
      * introv HIn.
        eapply wfQueue in HIn as wfMsg.
        inv wfMsg; constructors; hauto...
        ++ introv HIn'. eapply H3 in HIn' as [Hlt HBloc].
           splits...
           introv HIn'. hauto.
        ++ assert (qid0 <> n)
               by (eapply Mfresh in H0; omega).
           case_extend...
      * introv HIn. eapply HBId in HIn as [Hlt HBloc].
        splits...
        introv HLH. hauto.
    - eapply wfActors in Hlookup as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      constructors; hauto...
      * introv HC.
        assert (qid0 <> n).
          eapply wfC in HC as [?Q contra].
          intros eq; subst...
          eapply Mfresh in contra; omega.
        case_extend...
      * introv HIn.
        eapply wfQueue in HIn as wfMsg.
        inv wfMsg; constructors; hauto...
        ++ introv HIn'. eapply H3 in HIn' as [Hlt HBloc].
           splits...
           introv HIn'. hauto.
        ++ assert (qid0 <> n)
               by (eapply Mfresh in H0; omega).
           case_extend...
      * introv HIn. eapply HBId in HIn as [Hlt HBloc].
        splits...
        introv HLH. hauto.
  + Case "EAtEnd". SCase "Bestowed success".
    hauto.
    - eapply wfActors in H9 as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      constructors; hauto...
      * introv HC.
        unfold drop in HC.
        cases_if...
        assert (qid0 <> n).
          eapply wfC in HC as [?Q contra].
          intros eq; subst...
          eapply Mfresh in contra; omega.
        case_extend...
      * introv HIn.
        eapply wfQueue in HIn as wfMsg.
        inv wfMsg; constructors; hauto...
        ++ introv HIn'. eapply H3 in HIn' as [Hlt HBloc].
           splits...
           introv HIn'. hauto.
        ++ assert (qid0 <> n)
               by (eapply Mfresh in H0; omega).
           case_extend...
      * introv HIn. eapply HBId in HIn as [Hlt HBloc].
        splits...
        introv HLH. hauto.
    - eapply wfActors in Hlookup as wfActor'...
      inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
      constructors; hauto...
      * introv HC.
        assert (qid0 <> n).
          eapply wfC in HC as [?Q contra].
          intros eq; subst...
          eapply Mfresh in contra; omega.
        case_extend...
      * introv HIn.
        eapply wfQueue in HIn as wfMsg.
        inv wfMsg; constructors; hauto...
        ++ introv HIn'. eapply H3 in HIn' as [Hlt HBloc].
           splits...
           introv HIn'. hauto.
        ++ assert (qid0 <> n)
               by (eapply Mfresh in H0; omega).
           case_extend...
      * introv HIn. eapply HBId in HIn as [Hlt HBloc].
        splits...
        introv HLH. hauto.
Qed.

Lemma wf_heap_preservation :
  forall id M M' H H' n n' e e' l L C Q,
    id / (M, H, n); e ==> (M', H', n'); e' ->
    wf_cfg (M, H, n) ->
    wf_actor M H id (l, L, C, Q, e) ->
    wf_heap M' H'.
Proof with eauto using step_id_lt.
  introv Hstep wfCfg wfActor.
  inverts wfCfg as wfH wfM Mfresh Hfresh.
  constructors...
  + Case "Local heap disjointness".
    inverts wfH as Hdisj _ _.
    introv Hneq HLH1 HLH2 HIn.
    eapply step_id_lt in HLH1 as HId1...
    eapply step_id_lt in HLH2 as HId2...
    inv HId1...
    - inv HId2...
      * heap_case id1 id.
        ++ eapply step_local_heap_neq in HLH2...
           assert (exists L, LH H id = Some L) as Hex.
             remember (LH H id) as lkp.
             unfolds LH. find_actor id.
             rewrite Hlookup in Heqlkp. destruct lkp...
           inv Hex as [L' HLH].
           eapply step_allocates_n in HLH as Halloc...
           inv Halloc...
           -- unfolds LH. rewrite_and_invert...
           -- unfolds LH. rewrite_and_invert.
              inv HIn...
              introv contra. eapply Hfresh in HLH2.
              rewrite Forall_forall in HLH2. eapply HLH2 in contra.
              omega.
        ++ eapply step_local_heap_neq in HLH1...
           heap_case id2 id.
           -- assert (exists L, LH H id = Some L) as Hex.
                remember (LH H id) as lkp.
                unfolds LH. find_actor id.
                rewrite Hlookup in Heqlkp. destruct lkp...
           inv Hex as [L' HLH].
           eapply step_allocates_n in HLH as Halloc...
           inv Halloc...
           ** unfolds LH. rewrite_and_invert...
           ** unfolds LH. rewrite_and_invert.
              introv contra. inv contra...
              +++ eapply Hfresh in HLH1.
                  rewrite Forall_forall in HLH1. eapply HLH1 in HIn.
                  omega.
              +++ eapply Hdisj...
           -- eapply step_local_heap_neq in HLH2...
      * inv H1... heap_case id1 id.
        ++ folds (LH H' id). erewrite step_single_allocation in HLH1...
           contra... eapply Hfresh in HLH1...
           rewrite Forall_forall in HLH1. apply HLH1 in HIn.
           omega.
        ++ eapply step_local_heap_neq in HLH1...
           eapply Hfresh in HLH1.
           introv contra. inv contra...
           rewrite Forall_forall in HLH1.
           eapply HLH1 in HIn... omega.
    - inv H0. inv HIn...
      inv HId2 as [|[]]...
      erewrite step_single_allocation in HLH2...
      introv contra. eapply Hfresh in HLH2.
      rewrite Forall_forall in HLH2. apply HLH2 in contra...
      omega.
  + Case "Conversation disjointness".
    introv Hneq Hconv1 Hconv2 HC1 HC2.
    inverts wfH as _ Cdisj wfActors.
    intros contra; subst.
    eapply step_conv_lt in Hconv1 as Hid1...
    eapply step_conv_lt in Hconv2 as Hid2...
    inv Hid1 as [Hlt|[]]; try congruence.
    inv Hid2 as [Hlt'|[]]; try congruence.
    find_actor id1.
    find_actor id2.
    heap_case id id1.
    - eapply step_conversation_neq in Hconv2...
      eapply step_conversation_effect in Hconv1; hauto.
      inv Hconv1 as [|[]]...
      * unfolds conversation_disjointness.
        eapply Cdisj with (qid0 := qid') (qid' := qid') in Hneq; hauto.
      * eapply wfActors in Hlookup0 as wfActor'.
        inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
        eapply wfC in HC2 as [?Q HM]...
        eapply Mfresh in HM. omega.
    - eapply step_conversation_neq in Hconv1...
      heap_case id id2.
      * eapply step_conversation_effect in Hconv2; hauto.
        inv Hconv2 as [|[]]...
        ++ unfolds conversation_disjointness.
           eapply Cdisj with (qid0 := qid') (qid' := qid') in Hneq; hauto.
        ++ eapply wfActors in Hlookup as wfActor'.
           inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
        eapply wfC in HC1 as [?Q HM]...
        eapply Mfresh in HM. omega.
      * eapply step_conversation_neq in Hconv2...
        unfolds conversation_disjointness.
        eapply Cdisj with (qid0 := qid') (qid' := qid') in Hneq; hauto.
  + Case "Actor preservation".
    introv Hlookup.
    destruct_actor a.
    eapply wf_actor_preservation...
    constructors...
Qed.

Lemma actor_locs_preservation :
  forall id M M' H H' n n' e e' e'' l l' L L' C C' Q Q',
    id / (M, H, n); e ==> (M', H', n'); e' ->
    LH H id = Some L ->
    wf_actor M H id (l, L, C, Q, e) ->
    heapLookup H' id = Some (l', L', C', Q', e'') ->
    (forall l, In l (freeLocs e') -> In l L').
Proof with eauto using is_econtext, in_or_app.
  introv Hstep HLH wfActor Hlookup HIn.
  assert (forall l' : loc, In l' (freeLocs e) -> In l' L) as Hloc
      by (inv wfActor; eauto).
  assert (id < length H') as Hlt...
  assert (forall L'' l, LH H id = Some L'' -> In l L'' -> In l L') as Hmono.
    introv HLH' HIn'. eapply monotonic_local_heap...
    unfolds LH; crush.
  gen e'. gen e''. gen H. gen L.
  expr_cases (induction e) Case;
    intros; inv Hstep; simpls;
    try inv_ctx;
    try rewrite_and_invert;
    try contradiction;
    simpls...
  + Case "EApp".
    eapply wf_actor_ctx with (ctx := ctx_appl e2) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn...
  + Case "EApp".
    eapply wf_actor_ctx with (ctx := ctx_appr e1) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn...
  + Case "EApp".
    unfolds LH. rewrite Hlookup in HLH. inv HLH...
    eapply freeLocs_subst_in in HIn.
    inv HIn...
  + Case "ESend".
    eapply wf_actor_ctx with (ctx := ctx_send v t e2) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn...
  + Case "EMut".
    eapply wf_actor_ctx in wfActor as wfActor'...
  + Case "ENew".
    inv HIn... hauto.
    constructors...
  + Case "EBes".
    eapply wf_actor_ctx in wfActor as wfActor'...
  + Case "EAtStart".
    eapply wf_actor_ctx in wfActor as wfActor'...
  + Case "EAtEnd".
    eapply wf_actor_ctx in wfActor as wfActor'...
Qed.

Lemma actor_ids_preservation :
  forall id M M' H H' n n' e e' e'' l l' L L' C C' Q Q',
    id / (M, H, n); e ==> (M', H', n'); e' ->
    wf_actor M H id (l, L, C, Q, e) ->
    heapLookup H' id = Some (l', L', C', Q', e'') ->
    (forall id, In id (freeIds e') -> id < length H').
Proof with eauto using is_econtext, in_or_app, monotonic_heap.
  introv Hstep wfActor Hlookup HIn.
  assert (length H <= length H') as Hlt'...
  assert (forall id, In id (freeIds e) -> id < length H) as HId
      by (inverts wfActor; eauto).
  gen e'. gen e''. gen H. gen L.
  expr_cases (induction e) Case;
    intros; inv Hstep; simpls;
    try inv_ctx;
    try rewrite_and_invert;
    try contradiction;
    simpls...
  + Case "EApp".
    eapply wf_actor_ctx with (ctx := ctx_appl e2) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn... assert (id0 < length H)... omega.
  + Case "EApp".
    eapply wf_actor_ctx with (ctx := ctx_appr e1) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn... assert (id0 < length H)... omega.
  + Case "EApp".
    eapply freeIds_subst_in in HIn.
    inv HIn...
  + Case "ESend".
    eapply wf_actor_ctx with (ctx := ctx_send v t e2) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn... assert (id0 < length H)... omega.
  + Case "EMut".
    eapply wf_actor_ctx in wfActor as wfActor'...
  + Case "ENew".
    inv HIn; try contradiction...
    hauto.
  + Case "EBes".
    eapply wf_actor_ctx in wfActor as wfActor'...
  + Case "EAtStart".
    eapply wf_actor_ctx in wfActor as wfActor'...
  + Case "EAtEnd".
    eapply wf_actor_ctx in wfActor as wfActor'...
Qed.

Lemma actor_bids_preservation :
  forall id M M' H H' n n' e e' e'' l l' L L' C C' Q Q',
    id / (M, H, n); e ==> (M', H', n'); e' ->
    LH H id = Some L ->
    wf_actor M H id (l, L, C, Q, e) ->
    heapLookup H' id = Some (l', L', C', Q', e'') ->
    forall l id,
      In (l, id) (freeBIds e') ->
      id < length H' /\
      (forall L : list loc, LH H' id = Some L -> In l L).
Proof with eauto using is_econtext, in_or_app, monotonic_heap, step_local_heap_neq.
  introv Hstep HLH wfActor Hlookup HIn.
  assert (length H <= length H') as Hmono...
  assert (forall l' : loc, In l' (freeLocs e) -> In l' L) as Hloc
      by (inv wfActor; eauto).
  assert (forall l' id0,
             In (l', id0) (freeBIds e) ->
             id0 < length H /\
             forall L, LH H id0 = Some L -> In l' L) as HBId
      by (inverts wfActor; eauto).
  gen e'. gen e''. gen L.
  expr_cases (induction e) Case;
    intros; inv Hstep; simpls;
    try inv_ctx;
    try rewrite_and_invert;
    try contradiction;
    simpls...
  + Case "EApp".
    eapply wf_actor_ctx with (ctx := ctx_appl e2) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn...
    - splits; eapply IHe1 with (L := L)...
    - specializes HBId l0 id0 ___...
      inv HBId.
      splits; try omega.
      introv HLH'. destruct (id_eq_dec id0 id); subst...
      eapply monotonic_local_heap...
  + Case "EApp".
    eapply wf_actor_ctx with (ctx := ctx_appr e1) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn...
    - specializes HBId l0 id0 ___...
      inv HBId.
      splits; try omega.
      introv HLH'. destruct (id_eq_dec id0 id); subst...
      eapply monotonic_local_heap...
    - splits; eapply IHe2 with (L := L)...
  + Case "EApp".
    eapply freeBIds_subst_in in HIn.
    inv HIn...
  + Case "ESend".
    eapply wf_actor_ctx with (ctx := ctx_send v t e2) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn...
    - splits; eapply IHe1 with (L := L)...
    - specializes HBId l0 id0 ___...
      inv HBId.
      splits; try omega.
      introv HLH'. destruct (id_eq_dec id0 id); subst...
      eapply monotonic_local_heap...
  + Case "EMut".
    eapply wf_actor_ctx in wfActor as wfActor'...
  + Case "EBes".
    eapply wf_actor_ctx in wfActor as wfActor'...
  + Case "EBes".
    inv HIn; try contradiction...
    inv H... unfolds LH. rewrite Hlookup in HLH.
    inv HLH... splits...
    rewrite Hlookup...
    introv HLH. inv HLH...
  + Case "EAtStart".
    eapply wf_actor_ctx in wfActor as wfActor'...
  + Case "EAtEnd".
    eapply wf_actor_ctx in wfActor as wfActor'...
Qed.

(* In dire need of automation! *)
Lemma local_heap_freshness_preservation :
  forall id M M' H H' n n' e e',
    id / (M, H, n); e ==> (M', H', n'); e' ->
    local_heap_freshness H n ->
    local_heap_freshness H' n'.
Proof with hauto.
  introv Hstep Hfresh HLH.
  gen e'.
  expr_cases (induction e) Case;
    intros; inv Hstep; simpls;
    try inv_ctx...
  + Case "ESend".
    eapply Hfresh...
    crush.
  + Case "ESend".
    eapply Hfresh...
    crush.
  + Case "ENew".
    rewrite Forall_forall. introv HIn.
    inv HIn... assert (x < n)...
    assert (LH H id0 = Some L0) as HLH
        by hauto.
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "ENew".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "ENew".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "EAtStart".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    assert (LH H id0 = Some L) as HLH
        by hauto.
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "EAtStart".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    eapply Hfresh in HLH...
    rewrite Forall_forall in HLH...
  + Case "EAtStart".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    assert (LH H id0 = Some L) as HLH
        by hauto.
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "EAtStart".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    assert (LH H id0 = Some L) as HLH
        by hauto.
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "EAtStart".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "EAtStart".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    assert (LH H id0 = Some L) as HLH
        by hauto.
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "EAtStart".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "EAtStart".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    assert (LH H id0 = Some L) as HLH
        by hauto.
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "EAtStart".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    assert (LH H id0 = Some L) as HLH
        by hauto.
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "EAtStart".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "EAtEnd".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    assert (LH H id0 = Some L) as HLH
        by hauto.
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "EAtEnd".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "EAtEnd".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    assert (LH H id0 = Some L) as HLH
        by hauto.
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "EAtEnd".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
Qed.

Lemma queueMap_freshness_preservation :
  forall id M M' H H' n n' e e' l L C Q,
    id / (M, H, n); e ==> (M', H', n'); e' ->
    wf_actor M H id (l, L, C, Q, e) ->
    queueMap_freshness M n ->
    queueMap_freshness M' n'.
Proof with (hauto; eauto using in_or_app).
  introv Hstep wfActor Mfresh HM.
  inverts wfActor as _ HC _ _ _ _ _ _.
  gen e'. gen H. gen M.
  expr_cases (induction e) Case;
    intros; inv Hstep; simpls;
    try inv_ctx...
  + Case "ESend".
    unfold extend in HM.
    cases_if...
  + Case "ESend".
    unfold extend in HM.
    cases_if...
  + Case "ENew".
    assert (qid < n)...
  + Case "ENew".
    assert (qid < n)...
  + Case "EAtStart".
    unfold extend in HM. cases_if...
    eapply Mfresh in HM...
  + Case "EAtStart".
    unfold extend in HM. cases_if...
    eapply Mfresh in HM...
  + Case "EAtStart".
    unfold extend in HM. cases_if...
    eapply Mfresh in HM...
  + Case "EAtStart".
    unfold extend in HM. cases_if...
    eapply Mfresh in HM...
  + Case "EAtEnd".
    unfold extend in HM. cases_if...
    eapply Mfresh in HM...
  + Case "EAtEnd".
    unfold extend in HM. cases_if...
    eapply Mfresh in HM...
Qed.

Lemma step_preserves_queueMap_ids :
  forall id M M' H H' n n' e e' qid Q id',
    id / (M, H, n); e ==> (M', H', n'); e' ->
    queueMap_freshness M n ->
    M qid = Some (Q, id') ->
    exists Q', M' qid = Some (Q', id').
Proof with hauto.
  introv Hstep Mfresh HM.
  assert (qid <> n)
      by (eapply Mfresh in HM; omega).
  gen e'.
  expr_cases (induction e) Case; intros;
    inv Hstep; try solve[inv_ctx];
    try case_extend; try rewrite_and_invert...
Qed.

Lemma wf_queueMap_preservation :
  forall id M M' H H' n n' e e' l L C Q,
    id / (M, H, n); e ==> (M', H', n'); e' ->
    wf_cfg (M, H, n) ->
    wf_actor M H id (l, L, C, Q, e) ->
    wf_queueMap M' H'.
Proof with eauto using is_econtext.
  introv Hstep wfCfg wfActor.
  inverts wfCfg as wfH wfM Mfresh Hfresh.
  gen e'. gen H. gen M.
  expr_cases (induction e) Case; intros;
    inv Hstep; try inv_ctx...
  + Case "EApp".
    eapply wf_actor_ctx with (ctx := ctx_appl e2) in wfActor as wfActor'...
  + Case "EApp".
    eapply wf_actor_ctx with (ctx := ctx_appr e1) in wfActor as wfActor'...
  + Case "ESend".
    eapply wf_actor_ctx with (ctx := ctx_send v t e2) in wfActor as wfActor'...
  + Case "ESend".
    eapply wf_queueMap_heapUpdate; hauto...
    constructors...
  + Case "ESend".
    eapply wf_queueMap_heapUpdate; hauto...
    constructors...
  + Case "ESend".
    inverts wfActor as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
    splits 3; simpls...
    - unfold extend in H.
      cases_if; try inv_eq.
      * eapply wfM in H14 as [? [? [L' []]]]...
        introv HIn. eapply in_snoc in HIn.
        inv HIn...
        congruence.
      * eapply wfM...
    - unfold extend in H.
      cases_if; try inv_eq.
      * eapply wfM in H14 as [? [? [L' []]]]...
        introv HIn. eapply in_snoc in HIn.
        inv HIn...
        congruence.
      * eapply wfM...
    - unfold extend in H.
      cases_if; hauto.
      * eapply wfM in H14 as [? [? [L' []]]]...
        exists L'.
        splits...
        introv HIn.
        eapply in_snoc in HIn.
        inv HIn...
        ++ eapply H2 in H3 as wfMsg.
           inv wfMsg; try solve[constructors; hauto]...
           specializes H (Atomic qid) qid ___.
           congruence.
        ++ inv Hex as [t hasType].
           inv hasType...
           constructors...
           introv HIn. rewrite H9 in HIn. inv HIn.
      * eapply wfM in H as [? [? [L' []]]]...
        exists L'.
        splits...
        introv HIn.
        eapply H3 in HIn as wfMsg.
        inv wfMsg; try solve[constructors; hauto]...
        specializes H (Atomic qid1) qid1 ___.
        congruence.
  + Case "ESend".
    inverts wfActor as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
    splits 3; simpls...
    - unfold extend in H.
      cases_if; try inv_eq.
      * eapply wfM in H14 as [? [? [L' []]]]...
        introv HIn. eapply in_snoc in HIn.
        inv HIn...
        congruence.
      * eapply wfM...
    - unfold extend in H.
      cases_if; try inv_eq.
      * eapply wfM in H14 as [? [? [L' []]]]...
        introv HIn. eapply in_snoc in HIn.
        inv HIn...
        congruence.
      * eapply wfM...
    - unfold extend in H.
      cases_if; hauto.
      * eapply wfM in H14 as [? [? [L' []]]]...
        exists L'.
        splits...
        introv HIn.
        eapply in_snoc in HIn.
        inv HIn...
        ++ eapply H2 in H3 as wfMsg.
           inv wfMsg; try solve[constructors; hauto]...
           specializes H (Atomic qid) qid ___.
           congruence.
        ++ inv Hex as [t hasType].
           inv hasType...
           constructors; simpls...
           -- eexists... repeat constructors...
              eapply hasType_subsumption...
              introv HIn. case_extend...
              eapply free_in_env with (x := 0) in HIn as [? contra]...
              unfold extend in contra.
              cases_if.
           -- rewrite H9. simpls. introv HIn.
              inv HIn; try contradiction.
              specializes HBId l0 id0 ___.
           -- rewrite app_nil_r...
           -- rewrite app_nil_r...
      * eapply wfM in H as [? [? [L' []]]]...
        exists L'.
        splits...
        introv HIn.
        eapply H3 in HIn as wfMsg.
        inv wfMsg; try solve[constructors; hauto]...
        specializes H (Atomic qid1) qid1 ___.
        congruence.
  + Case "EMut".
    eapply wf_actor_ctx in wfActor as wfActor'...
  + Case "ENew".
    inverts wfActor as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
    splits 3; simpls...
    - eapply wfM...
    - introv HIn Hconv HC.
      hauto; eapply wfM...
      hauto. rewrite H9...
    - eapply wfM in H0 as [? [? [L' []]]]...
      hauto.
      * eexists... split...
        eapply wf_queue_heapUpdate; eauto using in_cons...
          inv wfH...
        introv HIn.
        eapply H3 in HIn as wfMsg.
        inv wfMsg; constructors; hauto.
        introv HIn'. eapply in_cons...
      * eexists. split...
        eapply wf_queue_heapUpdate; eauto using in_cons...
          inv wfH...
  + Case "ENew".
    inverts wfActor as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
    splits 3.
    - eapply wfM...
    - introv HIn Hconv HC.
      hauto.
      * inv HC.
      * eapply wfM...
    - hauto.
      * eapply wfM in H0 as [? [? [L' []]]]...
        assert (length H < length H)...
        omega.
      * eapply wfM in H0 as [? [? [L' []]]]...
        exists L'.
        splits...
        introv HIn.
        eapply H3 in HIn as wfMsg.
        inv wfMsg; constructors; hauto.
        ++ crush.
        ++ introv HIn'. eapply H7 in HIn' as [Hlt HBloc].
           splits...
           introv HLH. hauto.
  + Case "EBes".
    eapply wf_actor_ctx in wfActor as wfActor'...
  + Case "EAtStart".
    eapply wf_actor_ctx in wfActor as wfActor'...
  + Case "EAtStart".
    splits 3; simpls.
    - unfold extend in H0.
      cases_if; try inv_eq.
      eapply wfM...
    - unfold extend in H0.
      cases_if; try inv_eq.
      introv HIn Hconv HC.
      hauto; try solve [eapply wfM; eauto].
      * unfold extend in HC.
        cases_if; try inv_eq.
        eapply wfM... unfolds. rewrite H9...
      * eapply wfM... unfolds. rewrite H12...
      * unfold extend in HC.
        cases_if; try inv_eq.
        eapply wfM... unfolds. rewrite H9...
    - unfold extend in H0.
      cases_if; hauto.
      * exists L'.
        splits...
        introv HIn'. inv HIn'.
      * exists L'.
        splits...
        introv HIn'. inv HIn'.
      * exists L'.
        splits...
        introv HIn'. inv HIn'.
      * exists L'.
        splits...
        introv HIn'. inv HIn'.
      * exists L'.
        splits...
        eapply wfM in H0 as [? [? [L'' []]]]...
        introv HIn. eapply H4 in HIn as wfMsg.
        inv wfMsg; constructors; hauto.
        ++ introv HIn'. eapply H8 in HIn' as [Hlt HBloc].
           hauto.
        ++ assert (qid0 <> n)
               by (eapply Mfresh in H5; omega).
           case_extend...
      * exists L'.
        splits...
        eapply wfM in H0 as [? [? [L'' []]]]...
        introv HIn. eapply H4 in HIn as wfMsg.
        inv wfMsg; constructors; hauto.
        ++ introv HIn'. eapply H8 in HIn' as [Hlt HBloc].
           hauto.
        ++ assert (qid0 <> n)
               by (eapply Mfresh in H5; omega).
           case_extend...
      * exists L0.
        splits...
        eapply wfM in H0 as [? [? [L'' []]]]...
        introv HIn. eapply H4 in HIn as wfMsg.
        inv wfMsg; constructors; hauto.
        ++ introv HIn'. eapply H8 in HIn' as [Hlt HBloc].
           hauto.
        ++ assert (qid0 <> n)
               by (eapply Mfresh in H5; omega).
           case_extend...
      * eapply wfM in H0 as [? [? [L'' []]]]...
        exists L''.
        splits...
        introv HIn. eapply H4 in HIn as wfMsg.
        inv wfMsg; constructors; hauto.
        ++ introv HIn'. eapply H8 in HIn' as [Hlt HBloc].
           hauto.
        ++ assert (qid0 <> n)
               by (eapply Mfresh in H5; omega).
           case_extend...
      * eapply wfM in H0 as [? [? [L'' []]]]...
        exists L''.
        splits...
        introv HIn. eapply H4 in HIn as wfMsg.
        inv wfMsg; constructors; hauto.
        ++ introv HIn'. eapply H8 in HIn' as [Hlt HBloc].
           hauto.
        ++ assert (qid0 <> n)
               by (eapply Mfresh in H5; omega).
           case_extend...
  + Case "EAtStart".
    splits 3; simpls.
    - unfold extend in H0.
      cases_if; try inv_eq.
      eapply wfM...
    - unfold extend in H0.
      cases_if; try inv_eq.
      introv HIn Hconv HC.
      hauto; try solve [eapply wfM; eauto].
      * unfold extend in HC.
        cases_if; try inv_eq.
        eapply wfM... unfolds. rewrite H9...
      * eapply wfM... unfolds. rewrite H12...
      * unfold extend in HC.
        cases_if; try inv_eq.
        eapply wfM... unfolds. rewrite H9...
    - unfold extend in H0.
      cases_if; hauto.
      * exists L'.
        splits...
        introv HIn'. inv HIn'.
      * exists L'.
        splits...
        introv HIn'. inv HIn'.
      * exists L'.
        splits...
        introv HIn'. inv HIn'.
      * exists L'.
        splits...
        introv HIn'. inv HIn'.
      * exists L'.
        splits...
        eapply wfM in H0 as [? [? [L'' []]]]...
        introv HIn. eapply H4 in HIn as wfMsg.
        inv wfMsg; constructors; hauto.
        ++ introv HIn'. eapply H8 in HIn' as [Hlt HBloc].
           hauto.
        ++ assert (qid0 <> n)
               by (eapply Mfresh in H5; omega).
           case_extend...
      * exists L'.
        splits...
        eapply wfM in H0 as [? [? [L'' []]]]...
        introv HIn. eapply H4 in HIn as wfMsg.
        inv wfMsg; constructors; hauto.
        ++ introv HIn'. eapply H8 in HIn' as [Hlt HBloc].
           hauto.
        ++ assert (qid0 <> n)
               by (eapply Mfresh in H5; omega).
           case_extend...
      * exists L0.
        splits...
        eapply wfM in H0 as [? [? [L'' []]]]...
        introv HIn. eapply H4 in HIn as wfMsg.
        inv wfMsg; constructors; hauto.
        ++ introv HIn'. eapply H8 in HIn' as [Hlt HBloc].
           hauto.
        ++ assert (qid0 <> n)
               by (eapply Mfresh in H5; omega).
           case_extend...
      * eapply wfM in H0 as [? [? [L'' []]]]...
        exists L''.
        splits...
        introv HIn. eapply H4 in HIn as wfMsg.
        inv wfMsg; constructors; hauto.
        ++ introv HIn'. eapply H8 in HIn' as [Hlt HBloc].
           hauto.
        ++ assert (qid0 <> n)
               by (eapply Mfresh in H5; omega).
           case_extend...
      * eapply wfM in H0 as [? [? [L'' []]]]...
        exists L''.
        splits...
        introv HIn. eapply H4 in HIn as wfMsg.
        inv wfMsg; constructors; hauto.
        ++ introv HIn'. eapply H8 in HIn' as [Hlt HBloc].
           hauto.
        ++ assert (qid0 <> n)
               by (eapply Mfresh in H5; omega).
           case_extend...
  + Case "EAtEnd".
    eapply wf_actor_ctx in wfActor as wfActor'...
  + Case "EAtEnd".
    inverts wfH as _ _ wfActors.
    splits 3; simpls.
    - unfold extend in H0.
      cases_if; try inv_eq.
      * eapply wfM in H11 as [? [? [L'' []]]]...
        introv HIn. eapply in_snoc in HIn.
        inv HIn...
        congruence.
      * eapply wfM...
    - unfold extend in H0.
      cases_if; try inv_eq.
      * introv HIn Hconv HC.
        hauto; try solve [eapply wfM; eauto].
        ++ unfold drop in HC.
           cases_if; try inv_eq.
           eapply wfActors in H9 as wfActor'.
           inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
           eapply wfC in HC as [Q'' HM].
           eapply Mfresh in HM. omega.
        ++ assert (id' < length H).
             remember (heapLookup H id') as lkp.
             symmetry in Heqlkp.
             destruct lkp; hauto.
           find_actor id'. hauto.
           eapply wfActors in Hlookup as wfActor'.
           inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
           eapply wfC in HC as [Q'' HM].
           eapply Mfresh in HM. omega.
      * introv HIn Hconv HC.
        hauto.
        ++ unfold drop in HC. cases_if.
           eapply wfM... unfolds. rewrite H9...
        ++ eapply wfM...
    - unfold extend in H0.
      cases_if; hauto.
      * exists L0.
        splits...
        eapply wfM in H11 as [? [? [L'' []]]]...
        introv HIn. eapply in_snoc in HIn.
        inv HIn; try constructors...
        eapply H3 in H4 as wfMsg.
        inv wfMsg; constructors; hauto.
        ++ introv HIn'. eapply H8 in HIn' as [Hlt HBloc].
           hauto.
        ++ case_extend...
           specializes H0 (Atomic qid1) qid1 ___.
           congruence.
      * eapply wfActors in H9 as wfActor'.
        assert (id0 < length H)
            by (eapply conversation_lt in H10; eauto).
        find_actor id0. hauto.
        exists L1.
        splits...
        eapply wfM in H11 as [? [? [L'' []]]]...
        introv HIn. eapply in_snoc in HIn.
        inv HIn; try constructors...
        eapply H3 in H4 as wfMsg.
        inv wfMsg; constructors; hauto.
        ++ introv HIn'. eapply H8 in HIn' as [Hlt HBloc].
           hauto.
        ++ case_extend...
           specializes H0 (Atomic qid1) qid1 ___.
           congruence.
      * exists L0.
        splits...
        eapply wfM in H0 as [? [? [L'' []]]]...
        introv HIn.
        eapply H4 in HIn as wfMsg.
        inv wfMsg; constructors; hauto.
        ++ introv HIn'. eapply H8 in HIn' as [Hlt HBloc].
           hauto.
        ++ assert (qid1 <> n)
               by (eapply Mfresh in H5; omega).
           case_extend...
      * eapply wfM in H0 as [? [? [L'' []]]]...
        assert (id0 < length H)...
        find_actor id0. hauto.
        exists L''.
        splits...
        introv HIn.
        eapply H4 in HIn as wfMsg.
        inv wfMsg; try solve[constructors; hauto].
        ++ constructors; hauto...
           introv HIn'. eapply H7 in HIn' as [Hlt HBloc].
           hauto.
        ++ specializes H0 (Atomic qid1) qid1 ___.
           congruence.
  + Case "EAtEnd".
    inverts wfH as _ _ wfActors.
    splits 3; simpls.
    - unfold extend in H0.
      cases_if; try inv_eq.
      * eapply wfM in H11 as [? [? [L'' []]]]...
        introv HIn. eapply in_snoc in HIn.
        inv HIn...
        congruence.
      * eapply wfM...
    - unfold extend in H0.
      cases_if; try inv_eq.
      * introv HIn Hconv HC.
        hauto; try solve [eapply wfM; eauto].
        ++ unfold drop in HC.
           cases_if; try inv_eq.
           eapply wfActors in H9 as wfActor'.
           inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
           eapply wfC in HC as [Q'' HM].
           eapply Mfresh in HM. omega.
        ++ assert (id' < length H).
             remember (heapLookup H id') as lkp.
             symmetry in Heqlkp.
             destruct lkp; hauto.
           find_actor id'. hauto.
           eapply wfActors in Hlookup as wfActor'.
           inverts wfActor' as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
           eapply wfC in HC as [Q'' HM].
           eapply Mfresh in HM. omega.
      * introv HIn Hconv HC.
        hauto.
        ++ unfold drop in HC. cases_if.
           eapply wfM... unfolds. rewrite H9...
        ++ eapply wfM...
    - unfold extend in H0.
      cases_if; hauto.
      * exists L0.
        splits...
        eapply wfM in H11 as [? [? [L'' []]]]...
        introv HIn. eapply in_snoc in HIn.
        inv HIn; try constructors...
        eapply H3 in H4 as wfMsg.
        inv wfMsg; constructors; hauto.
        ++ introv HIn'. eapply H8 in HIn' as [Hlt HBloc].
           hauto.
        ++ case_extend...
           specializes H0 (Atomic qid1) qid1 ___.
           congruence.
      * eapply wfActors in H9 as wfActor'.
        assert (id0 < length H)
            by (eapply conversation_lt in H10; eauto).
        find_actor id0. hauto.
        exists L1.
        splits...
        eapply wfM in H11 as [? [? [L'' []]]]...
        introv HIn. eapply in_snoc in HIn.
        inv HIn; try constructors...
        eapply H3 in H4 as wfMsg.
        inv wfMsg; constructors; hauto.
        ++ introv HIn'. eapply H8 in HIn' as [Hlt HBloc].
           hauto.
        ++ case_extend...
           specializes H0 (Atomic qid1) qid1 ___.
           congruence.
      * exists L0.
        splits...
        eapply wfM in H0 as [? [? [L'' []]]]...
        introv HIn.
        eapply H4 in HIn as wfMsg.
        inv wfMsg; constructors; hauto.
        ++ introv HIn'. eapply H8 in HIn' as [Hlt HBloc].
           hauto.
        ++ assert (qid1 <> n)
               by (eapply Mfresh in H5; omega).
           case_extend...
      * eapply wfM in H0 as [? [? [L'' []]]]...
        assert (id0 < length H)...
        find_actor id0. hauto.
        exists L''.
        splits...
        introv HIn.
        eapply H4 in HIn as wfMsg.
        inv wfMsg; try solve[constructors; hauto].
        ++ constructors; hauto...
           introv HIn'. eapply H7 in HIn' as [Hlt HBloc].
           hauto.
        ++ specializes H0 (Atomic qid1) qid1 ___.
           congruence.
Qed.

Theorem preservation :
  forall id cfg cfg',
    wf_cfg cfg ->
    step id cfg cfg' ->
    wf_cfg cfg'.
Proof with eauto.
  introv wfCfg Hstep.
  inv wfCfg as [M H n wfH wfM Mfresh Hfresh].
  inverts wfH as Hdisj Cdisj wfActors.
  inv Hstep.
  + Case "EvalActorMsg".
    constructors...
    - SCase "Well-formed heap".
      constructors.
      * SSCase "Local heap disjointness".
        introv Hneq HLH1 HLH2 HIn.
        hauto.
        ++ eapply Hdisj...
           unfolds. rewrite H5...
        ++ eapply Hdisj...
           unfolds. rewrite H5...
      * SSCase "Conversation disjointness".
        introv Hneq Hconv1 Hconv2 HC1 HC2.
        hauto; eapply Cdisj; hauto.
      * SSCase "Well-formed actors".
        introv Hlookup.
        hauto.
        ++ assert (wf_actor M H id0 (l, L, C, Msg v' :: Q, v)) as wfActor...
           inverts wfActor as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
           assert (In (Msg v') (Msg v' :: Q)) as wfMsg
               by (constructors; eauto).
           apply wfQueue in wfMsg.
           constructors; eauto using in_cons.
           -- eapply wf_queue_heapUpdate;
                eauto using in_cons.
           -- inverts wfMsg as [t hasType].
              exists t. repeat constructors...
           -- inv wfMsg. introv HIn. simpls.
              apply in_app_or in HIn.
              inverts HIn as HIn... inv HIn...
              contradiction.
           -- inv wfMsg. heap_rewrite.
              introv HIn. simpls.
              apply in_app_or in HIn.
              inv HIn... contradiction.
           -- inverts wfMsg as Hex' Hloc' HId' HBId'.
              introv HIn. simpls.
              apply in_app_or in HIn.
              inv HIn; try contradiction...
              hauto. splits...
              introv HLH'. inv_eq.
              eapply HBId' in H0 as [? ?]...
              rewrite H5 in H1...
        ++ destruct_actor a.
           eapply wfActors in Hlookup as wfActor.
           inverts wfActor as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
           constructors; hauto.
           -- eapply wf_queue_heapUpdate...
           -- introv HIn.
              eapply HBId in HIn as [? ?]...
              split...
              introv HLH'. hauto.
    - SCase "Well-formed queue map".
      introv HM...
      eapply wfM in HM as [Hatomic [Hend [L' [HLH wfQueue]]]].
      splits...
      * introv HIn Hconv.
        hauto. eapply Hend...
        rewrite H5...
      * exists L'.
        splits; hauto.
        eapply wf_queue_heapUpdate...
    - SCase "Local heap freshness".
      introv HLH'. unfolds LH.
      hauto.
      apply Hfresh with (id := id0).
      hauto.
  + Case "EvalActorPrivateMsg".
    constructors.
    - SCase "Well-formed heap".
      constructors...
      * SSCase "Local heap disjointness".
        introv Hneq HLH1 HLH2 HIn.
        hauto; eapply Hdisj; hauto.
      * SSCase "Conversation disjointness".
        introv Hneq Hconv1 Hconv2 HC1 HC2.
        hauto; eapply Cdisj; hauto.
      * SSCase "Well-formed actors".
        introv Hlookup.
        hauto.
        ++ eapply wfActors in H4 as wfActor.
           inverts wfActor as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
           eapply wfM in H7 as wfMqid.
           inv wfMqid as [Hatomic' [Hend' [L' [HLH wfQueue']]]].
           specializes wfQueue' (Msg v') ___.
             constructors...
           constructors; simpls; hauto.
           -- introv HC. eapply wfC in HC as [Q''].
              case_extend... rewrite_and_invert...
           -- introv HIn.
              eapply wfQueue in HIn as wfMsg.
              inv wfMsg; hauto.
              ** constructors; hauto.
                 introv HIn'. eapply H3 in HIn' as [Hlt HBloc].
                 splits...
                 hauto.
              ** destruct (id_eq_dec qid qid0); subst; constructors...
                 case_extend...
              ** constructors...
           -- inverts wfQueue' as [t hasType].
              exists t. repeat constructors...
           -- introv HIn.
              inv wfQueue'. hauto.
              eapply in_app_or in HIn. simpls. inv HIn...
              inv H0... contradiction.
           -- introv HIn. rewrite app_nil_r in HIn.
              inv wfQueue'...
           -- introv HIn. rewrite app_nil_r in HIn.
              inv wfQueue'. hauto.
              eapply H5 in HIn as [Hlt HBloc].
              splits... introv HLH. inv_eq...
              hauto.
        ++ eapply wfActors in Hlookup as wfActor.
           inverts wfActor as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
           constructors; hauto.
           -- introv HC. eapply wfC in HC as [Q'' HM].
              destruct (id_eq_dec qid qid0); subst.
              ** rewrite_and_invert. eexists...
              ** case_extend...
           -- introv HIn.
              eapply wfQueue in HIn as wfMsg.
              inv wfMsg; constructors; hauto...
              ** introv HIn'. eapply H3 in HIn' as [Hlt HBloc].
                 split...
                 hauto.
              ** case_extend...
           -- introv HIn. eapply HBId in HIn as [Hlt HBloc].
              split...
              hauto.
    - SCase "Well-formed queue map".
      introv HM...
      unfold extend in HM. cases_if...
      * inv_eq. eapply wfM in H7 as [Hatomic [Hend [L' [HLH wfQueue]]]].
        splits...
        ++ introv HIn. eapply Hatomic.
           eapply in_cons...
        ++ introv HIn Hconv. hauto.
           -- eapply Hend; eauto using in_cons...
              rewrite H4...
           -- eapply Hend...
              eapply in_cons...
        ++ exists L'...
           splits; hauto.
           introv HIn.
           specializes wfQueue msg ___.
             eauto using in_cons.
           inv wfQueue; try solve [constructors; hauto].
           -- constructors; hauto.
              introv HIn'. eapply H3 in HIn' as [Hlt HBloc].
              split...
              hauto.
           -- specializes Hatomic (Atomic qid) qid ___.
                eauto using in_cons.
              contradiction.
      * eapply wfM in HM as [Hatomic [Hend [L' [HLH wfQueue]]]].
        splits...
        ++ introv HIn Hconv. hauto.
           eapply Hend...
           rewrite H4...
        ++ exists L'...
           splits; hauto.
           introv HIn. eapply wfQueue in HIn as wfMsg.
           inv wfMsg; try solve[constructors; hauto].
           -- constructors; hauto.
              introv HIn'. eapply H5 in HIn' as [Hlt HBloc].
              split...
              hauto.
           -- specializes Hatomic (Atomic qid1) qid1 ___.
              contradiction.
    - SCase "Queue map freshness".
      introv HM. unfold extend in HM. cases_if...
    - SCase "Local heap freshness".
      introv HLH'. unfolds LH.
      hauto.
      apply Hfresh with (id := id0).
      hauto.
  + Case "EvalActorPrivateEnd".
    constructors.
    - SCase "Well-formed heap".
      constructors...
      * SSCase "Local heap disjointness".
        introv Hneq HLH1 HLH2 HIn.
        hauto; eapply Hdisj; hauto.
      * SSCase "Conversation disjointness".
        introv Hneq Hconv1 Hconv2 HC1 HC2.
        hauto; eapply Cdisj; hauto.
      * SSCase "Well-formed actors".
        introv Hlookup.
        hauto.
        ++ eapply wfActors in H4 as wfActor.
           inverts wfActor as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
           constructors; simpls; hauto.
           -- introv HC. eapply wfC in HC as Hex'.
              inv Hex' as [Q'' HM].
              case_drop... rewrite_and_invert...
              eapply wfM in H7 as [Hatomic' [Hend [L' [HLH wfQueue']]]].
              specializes Hend id' id' C qid0 ___.
                constructors... hauto.
              contradiction.
           -- introv HIn.
              eapply in_cons with (a := Atomic qid) in HIn as HIn'.
              eapply wfQueue in HIn' as wfMsg. clear HIn'.
              inv wfMsg; hauto.
              ** constructors; hauto.
                 introv HIn'. eapply H3 in HIn' as [Hlt HBloc].
                 splits...
                 hauto.
              ** assert (qid <> qid0).
                   introv eq; subst.
                   inv HnDup. apply H3. eapply filter_In...
                   constructors... case_drop...
              ** constructors...
           -- inv HnDup...
           -- introv HIn.
              eapply HBId in HIn as [Hlt HBloc].
              splits... introv HLH.
              hauto.
        ++ eapply wfActors in Hlookup as wfActor.
           inverts wfActor as Hthis wfC wfQueue Hatomic HnDup Hex Hloc HId HBId.
           constructors; hauto.
           -- introv HC. eapply wfC in HC as Hex'.
              inv Hex' as [Q'' HM].
              case_drop... rewrite_and_invert...
              eapply wfM in H7 as [Hatomic' [Hend [L' [HLH wfQueue']]]].
              specializes Hend id0 id' C0 qid0 ___.
                constructors... hauto.
              contradiction.
           -- introv HIn.
              eapply wfQueue in HIn as wfMsg.
              inv wfMsg; hauto.
              ** constructors; hauto.
                 introv HIn'. eapply H3 in HIn' as [Hlt HBloc].
                 splits...
                 hauto.
              ** constructors... case_drop...
              ** constructors...
           -- introv HIn. eapply HBId in HIn as [Hlt HBloc].
              split...
              hauto.
    - SCase "Well-formed queue map".
      introv HM...
      unfold drop in HM. cases_if...
      eapply wfM in HM as [Hatomic [Hend [L' [HLH wfQueue]]]].
      splits...
      * introv HIn Hconv HC. eapply Hend...
        hauto.
      * exists L'...
        splits; hauto.
        introv HIn.
        eapply wfQueue in HIn as wfMsg.
        inv wfMsg; try solve[constructors; hauto].
        -- constructors; hauto.
           introv HIn'. eapply H5 in HIn' as [Hlt HBloc].
           split...
           hauto.
        -- specializes Hatomic (Atomic qid1) qid1 ___.
           contradiction.
    - SCase "Queue map freshness".
      introv HM. unfold drop in HM. cases_if...
    - SCase "Local heap freshness".
      introv HLH'. unfolds LH.
      hauto.
      apply Hfresh with (id := id0).
      hauto.
  + Case "EvalActorRun".
    assert (wf_actor M H id (l, L, C, Q, e)) as wfActor...
    inverts wfActor as Hthis wfC wfQueue Hatomic HnDup (t & hasType) Hloc HId HBId.
    assert (wf_heap M' H') as wfH'.
      eapply wf_heap_preservation...
      constructors...
      constructors...
      assert (wf_queueMap M' H') as wfM'.
        eapply wf_queueMap_preservation in H6...
        constructors... constructors...
    constructors.
    - assert (forall id1 id2 L1 L2,
                 id1 <> id2 ->
                 LH H' id1 = Some L1 ->
                 LH H' id2 = Some L2 ->
                 (forall l : loc, In l L1 -> ~ In l L2)) as Hdisj'
          by (inverts wfH' as (? & ?); eauto).
      assert (wf_actor M' H' id (l, L', C', Q', e'')) as wfActor
          by (inverts wfH' as [_ ?]; eauto).
      assert (conversation_disjointness H')
          by (inverts wfH'; eauto).
      eapply wf_heap_heapUpdate; try omega...
      eapply type_preservation in hasType...
      constructors...
      * inv wfActor...
      * introv HC.
        assert (conv H id = Some C) as Hconv
            by hauto.
        assert (conv H' id = Some C') as Hconv'
            by hauto.
        eapply step_conversation_effect in HC as Halt...
        inv Halt as [|[]]...
        -- eapply wfC in H1 as [C'']...
           eapply step_preserves_queueMap_ids...
      * eapply wf_queue_preservation...
        constructors... constructors...
      * introv HIn.
        inverts wfActor...
      * inverts wfActor...
      * eapply actor_locs_preservation...
        unfolds LH. crush.
      * eapply actor_ids_preservation...
      * eapply actor_bids_preservation...
        unfolds LH. crush.
    - SCase "Well-formed queue map".
      splits 3.
      * eapply wfM'...
      * introv HIn Hconv HC.
        heap_case id id'.
        ++ eapply wfM'...
           unfolds. rewrite H7...
        ++ eapply wfM'...
      * hauto.
        ++ exists L'.
           splits...
           introv HIn.
           eapply wfM' in H0 as [Hatomic' [Hend [L'' [HLH wfQueue']]]].
           eapply wfQueue' in HIn as wfMsg.
           inv wfMsg; constructors; hauto.
           introv HIn'. eapply H3 in HIn' as [Hlt HBloc].
           splits...
           hauto.
        ++ eapply wfM' in H0 as [Hatomic' [Hend [L'' [HLH wfQueue']]]].
           exists L''.
           splits...
           introv HIn. eapply wfQueue' in HIn as wfMsg.
           inv wfMsg; constructors; hauto.
           introv HIn'. eapply H3 in HIn' as [Hlt HBloc].
           splits...
           hauto.
    - SCase "Queue map freshness".
      eapply queueMap_freshness_preservation...
    - SCase "Local heap freshness".
      introv HLH'. rewrite Forall_forall. introv HIn.
      unfolds LH. hauto.
      * eapply local_heap_freshness_preservation in H6...
        unfolds local_heap_freshness.
        specializes H6 L0 id0 ___.
          hauto.
        rewrite Forall_forall in H6...
      * eapply local_heap_freshness_preservation in H6...
        unfolds local_heap_freshness.
        specializes H6 L0 id0 ___.
        rewrite Forall_forall in H6...
Qed.