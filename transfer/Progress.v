Require Import SyntaxProp.
Require Import StaticProp.
Require Import DynamicProp.
Require Import WellFormednessProp.

Lemma actor_progress :
  forall O H n l L Q e id,
    wf_cfg (O, H, n) ->
    wf_actor O H (l, L, Q, e) ->
    id < length H ->
    (exists O' H' n' e', id / (O, H, n) ; e ==> (O', H', n') ; e') \/ is_val e.
Proof with eauto 6 using is_val, step_actor, is_econtext.
  introv wfCfg wfActor wfId.
  assert (exists t, empty |- e \in t) as [t hasType].
    inv wfActor...
  remember empty as Gamma.
  hasType_cases(induction hasType) Case; subst...
  + Case "T_Var".
    inv Hlookup.
  + Case "T_NewPassive".
    left. apply heapLookup_lt in wfId as [[[[? ?] ?] ?] Hlookup]...
  + Case "T_NewTrans".
    left. apply heapLookup_lt in wfId as [[[[? ?] ?] ?] Hlookup]...
  + Case "T_Mutate".
    apply wf_actor_ctx in wfActor...
    crush.
    - left. repeat constructors...
    - left. inv H0; inv hasType...
  + Case "T_Apply".
    assert (wf_actor O H (l, L, Q, e1)) as wfActor'.
    apply wf_actor_ctx with (ctx := ctx_appl e2)...
    crush.
    - left. apply EvalContext with (ctx := ctx_appl e2) in H0...
    - assert (wf_actor O H (l, L, Q, e2)) as wfActor''.
      apply wf_actor_ctx with (ctx := ctx_appr e1)...
      crush.
      * left. apply EvalContext with (ctx := ctx_appr e1) in H1...
      * inv H0; try solve[inv hasType1]...
        constructors...
  + Case "T_Send".
    assert (wf_actor O H (l, L, Q, e)) as wfActor'.
    apply wf_actor_ctx with (ctx := ctx_send x TPas e')...
    crush.
    - left. apply EvalContext with (ctx := ctx_send x TPas e') in H1...
    - unfold is_active in Hactive.
      inverts wfActor' as Hthis HOthis wfQueue Hex Hloc HId HTId.
      destruct a; inv Hactive.
      * SCase "ActorSend".
        left. inv H1; try solve[inv hasType1]...
        simpls.
        assert (id0 < length H) as Hlt...
        apply heapLookup_lt in Hlt as [[[[? ?] ?] ?] Hlookup]...
      * SCase "TransSend".
        left. inv H1; try solve[inv hasType1]...
        simpls.
        specializes HTId l0 ___.
        inv HTId as [id' HO].
        inverts wfCfg as wfH wfO Hfresh.
        inverts wfO as wfO.
        specializes wfO l0 id' ___...
        inv wfO as [Hlt HLH']...
        apply heapLookup_lt in Hlt as [[[[? ?] ?] ?] Hlookup]...
        heap_case id id'...
Qed.

Theorem progress :
  forall O H n id,
    wf_cfg (O, H, n) ->
    id < length H ->
    (exists cfg', step id (O, H, n) cfg') \/ actor_done (O, H, n) id.
Proof with eauto using step_preserves_this.
  introv wfCfg Hlt.
  assert (exists a, heapLookup H id = Some a) as [[[[l L] Q] e] Hlookup].
    apply heapLookup_lt in Hlt...
  assert (wf_actor O H (l, L, Q, e)) as wfActor.
    inverts wfCfg as wfH. inverts wfH as [_ wfActors]...
  apply actor_progress with (l := l) (L := L) (Q := Q) (e := e) (id := id) in wfCfg...
  inv wfCfg as [Hex | Hdone].
  + Case "e steps".
    left.
    inv Hex as [O' [H' [n' [e' Hstep]]]].
    assert (exists L' Q' e'', heapLookup H' id = Some (l, L', Q', e'')) as Hlookup'...
    destruct Hlookup' as [? [? [? ?]]].
    eapply EvalActorRun in Hstep...
  + Case "is_val e".
    destruct Q.
    - SCase "Q empty".
      right.
      unfolds. rewrite Hlookup.
      constructors...
    - SCase "Q non-empty".
      left.
      exists (O, heapUpdate H id (l, L, Q, EApp e0 (ELoc l)), n).
      constructors...
Qed.
