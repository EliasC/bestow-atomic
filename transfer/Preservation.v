Require Import SyntaxProp.
Require Import StaticProp.
Require Import DynamicProp.
Require Import WellFormednessProp.

Require Import MapProp.

Hint Unfold subst.

Lemma type_preservation :
  forall id H H' n n' e e' t,
    empty |- e \in t ->
    id / (H, n); e ==> (H', n'); e' ->
    empty |- e' \in t.
Proof with eauto using hasType, hasType_subst.
  introv hasType Hstep. gen e'.
  remember empty as Gamma.
  hasType_cases(induction hasType) Case; intros; inv Hstep;
  try solve[inv_ctx; constructors; eauto];
  try constructors...
  inv hasType1...
Qed.

Hint Rewrite Forall_forall.

Lemma wf_ownerMap_preservation :
  forall id O O' H H' n n' e e' l L Q,
    id / (O, H, n); e ==> (O', H', n'); e' ->
    wf_cfg (O, H, n) ->
    wf_actor O H (l, L, Q, e) ->
    wf_ownerMap O' H'.
Proof with eauto using is_econtext.
  introv Hstep wfCfg wfActor.
  inverts wfCfg as _ wfO Hfresh.
  gen e'. gen H.
  expr_cases (induction e) Case;
    intros; inv Hstep; simpls;
    try inv_ctx;
    try rewrite_and_invert...
  + Case "EApp". eapply wf_actor_ctx with (ctx := ctx_appl e2) in wfActor...
  + Case "EApp". eapply wf_actor_ctx with (ctx := ctx_appr e1) in wfActor...
  + Case "ESend". eapply wf_actor_ctx with (ctx := ctx_send v t e2) in wfActor...
  + Case "ESend". eapply wf_ownerMap_heapUpdate... unfolds; hauto.
  + Case "ESend". eapply wf_ownerMap_heapUpdate... unfolds; hauto.
  + Case "EMut". eapply wf_actor_ctx in wfActor...
  + Case "ENew".
    constructors...
    introv HO. hauto.
    - splits...
      introv Heq. inv_eq.
      apply in_cons.
      eapply wfO in HO as [Hlt HLH].
      eapply HLH. unfolds LH; crush.
    - eapply wfO in HO as [Hlt HLH].
      splits...
  + Case "ENew".
    constructors.
    introv HO. hauto.
    - splits...
      introv Heq. inv_eq.
      eapply in_cons.
      eapply wfO in HO as [Hlt HLH].
      eapply HLH. unfolds LH; crush.
    - eapply wfO in HO as [Hlt HLH].
      splits...
  + Case "ENew".
    constructors.
    inverts wfO as wfO.
    introv HO. splits...
    - hauto. unfold extend in HO.
      cases_if.
      * inv_eq...
      * apply wfO in HO as [Hlt HLH]...
    - unfold extend in HO.
      cases_if.
      * hauto; crush.
      * apply wfO in HO as [Hlt HLH]...
        hauto; crush.
Qed.

Lemma wf_queue_preservation :
  forall id id' O O' H H' n n' e e' e'' l l' L L' Q Q',
    id / (O, H, n); e ==> (O', H', n'); e' ->
    wf_cfg (O, H, n) ->
    wf_actor O H (l, L, Q, e) ->
    (forall id a, heapLookup H id = Some a -> wf_actor O H a) ->
    heapLookup H' id' = Some (l', L', Q', e'') ->
    wf_queue O' H' L' Q'.
Proof with eauto using is_econtext.
  introv Hstep wfCfg wfActor wfActors Hlookup.
  assert (id' < length H') as Hlt...
  assert (forall L'' l, LH H id' = Some L'' -> In l L'' -> In l L') as Hmono.
    introv HLH HIn. eapply monotonic_local_heap...
    unfolds LH; crush.
  inverts wfCfg as wfH wfO Hfresh.
  inverts wfH as Hdisj _.
  gen e'. gen H.
  expr_cases (induction e) Case;
    intros; inv Hstep; simpls;
    try inv_ctx;
    try rewrite_and_invert...
  + Case "EApp". eapply wf_actor_ctx with (ctx := ctx_appl e2) in wfActor...
  + Case "EApp". eapply wf_actor_ctx with (ctx := ctx_appr e1) in wfActor...
  + Case "EApp". apply wfActors in Hlookup... inv Hlookup...
  + Case "ESend". eapply wf_actor_ctx with (ctx := ctx_send v t e2) in wfActor...
  + Case "ESend".
    hauto.
    - eapply wfActors in H12 as H'. inv H'.
      eapply wf_queue_heapUpdate in H12...
      eapply wf_queue_snoc...
      inverts wfActor as [t hasType].
      constructors; simpls...
      ++ inv hasType...
      ++ inv hasType... introv HIn.
         rewrite H20 in HIn. simpls.
         inv HIn; try contradiction...
    - eapply wfActors in Hlookup.
      unfolds. introv HIn.
      inv Hlookup...
      eapply H6 in HIn as wfMsg.
      inv wfMsg...
      constructors; hauto.
  + Case "ESend".
    hauto.
    - eapply wfActors in H14 as H'. inv H'.
      eapply wf_queue_heapUpdate in H14...
      eapply wf_queue_snoc...
      inverts wfActor as [t hasType].
      constructors; simpls...
      ++ inv hasType...
         eexists... repeat constructors...
         eapply hasType_subsumption...
         introv HIn.
         case_extend...
         eapply free_in_env in HIn as [t' contra]...
         rewrite extend_neq in contra...
         unfolds activeEnv... simpls...
      ++ inv hasType... introv HIn.
         rewrite H22 in HIn. contradiction.
    - eapply wfActors in Hlookup.
      unfolds. introv HIn.
      inv Hlookup...
      eapply H6 in HIn as wfMsg.
      inv wfMsg...
      constructors; hauto.
  + Case "ESend".
    eapply wfActors in Hlookup as wfActor'.
    inv wfActor'...
  + Case "EMut". eapply wf_actor_ctx with (ctx := ctx_mut) in wfActor...
  + Case "EMut". apply wfActors in Hlookup... inv Hlookup...
  + Case "ENew".
    hauto.
    - eapply wfActors in H9 as wfActor'. inv wfActor'.
      eapply wf_queue_heapUpdate in H9...
      unfolds wf_queue.
      introv HIn. apply H6 in HIn.
      inv HIn. constructors...
      introv HIn. eapply H1 in HIn as []...
    - eapply wfActors in Hlookup. inv Hlookup.
      unfolds wf_queue. introv HIn.
      eapply H6 in HIn. inv HIn.
      constructors; hauto.
  + Case "ENew".
    eapply wf_actors_heapExtend in Hlookup...
    - inv Hlookup...
    - constructors; crush.
      * remember (O' n) as lkp.
        destruct lkp...
        symmetry in Heqlkp. eapply ownerMap_fresh in Heqlkp... omega.
      * repeat constructors.
  + Case "ENew".
    hauto.
    - introv HIn.
      eapply wfActors in H9 as wfActor'...
      inv wfActor'.
      eapply H6 in HIn. inv HIn.
      constructors; hauto.
      * introv HIn. eapply H1 in HIn as [Hlt' HBloc].
        splits...
        assert (l0 <> n).
          eapply local_heap_fresh'... unfolds. rewrite H9...
        case_extend.
      * introv HIn.
        eapply H3 in HIn as [id'' HO].
        assert (l0 <> n)...
        rewrite extend_neq...
    - introv HIn.
      eapply wfActors in Hlookup as wfActor'...
      inv wfActor'.
      eapply H6 in HIn. inv HIn.
      constructors; hauto.
      * introv HIn. eapply H1 in HIn as [Hlt' HBloc].
        splits...
        assert (l1 <> n).
          eapply local_heap_fresh'...
          unfolds. rewrite Hlookup...
        case_extend...
      * introv HIn.
        eapply H3 in HIn as [id'' HO].
        assert (l1 <> n)...
        rewrite extend_neq...
Qed.

Lemma wf_actor_preservation :
  forall id id' O O' H H' n n' e e' e'' l l' L L' Q Q',
    id / (O, H, n); e ==> (O', H', n'); e' ->
    wf_ownerMap O H ->
    wf_heap O H ->
    (forall L id, LH H id = Some L -> Forall (fun l => l < n) L) ->
    wf_actor O H (l, L, Q, e) ->
    heapLookup H' id' = Some (l', L', Q', e'') ->
    wf_actor O' H' (l', L', Q', e'').
Proof with eauto using is_econtext.
  introv Hstep wfO wfH Hfresh wfActor Hlookup.
  inverts wfH as Hdisj wfActors.
  gen e'. gen H.
  expr_cases (induction e) Case;
    intros; inv Hstep; simpls;
    try inv_ctx;
    try rewrite_and_invert...
  + Case "EApp". eapply wf_actor_ctx with (ctx := ctx_appl e2) in wfActor...
  + Case "EApp". eapply wf_actor_ctx with (ctx := ctx_appr e1) in wfActor...
  + Case "ESend". eapply wf_actor_ctx with (ctx := ctx_send v t e2) in wfActor...
  + Case "ESend".
    hauto.
    - eapply wfActors in H12 as wfActor'. inv wfActor'.
      constructors...
      * eapply wf_queue_heapUpdate...
        eapply wf_queue_snoc...
        inverts wfActor as [t hasType].
        constructors; simpls...
        ++ inv hasType...
        ++ inv hasType... introv HIn.
           rewrite H20 in HIn. simpls.
           inv HIn.
      * hauto.
    - eapply wfActors in Hlookup as wfActor'. inv wfActor'.
      constructors...
      * eapply wf_queue_heapUpdate...
      * hauto.
  + Case "ESend".
    hauto.
    - eapply wfActors in H14 as wfActor'. inv wfActor'.
      constructors...
      * eapply wf_queue_heapUpdate...
        eapply wf_queue_snoc...
        inverts wfActor as [t hasType].
        constructors; simpls...
        ++ inv hasType...
           exists TUnit. constructors...
           -- eapply hasType_subsumption...
              simpls. crush.
           -- eapply hasType_subsumption...
              introv HIn.
              eapply free_in_env in HIn as [t Heq]...
              unfold extend in Heq. cases_if...
              inv_eq.
              case_extend.
        ++ inv hasType... introv HIn.
           rewrite H22 in HIn. inv HIn.
      * hauto.
    - eapply wfActors in Hlookup as wfActor'. inv wfActor'.
      constructors...
      * eapply wf_queue_heapUpdate...
      * hauto.
  + Case "EMut". eapply wf_actor_ctx in wfActor...
  + Case "ENew".
    hauto.
    - eapply wfActors in H9 as wfActor'. inv wfActor'.
      constructors...
      * crush.
      * eapply wf_queue_heapUpdate...
        ++ introv HIn.
           eapply H6 in HIn as wfMsg.
           inv wfMsg.
           constructors...
           introv HIn'. eapply H1 in HIn' as []...
           crush.
        ++ crush.
      * crush.
      * hauto.
    - eapply wfActors in Hlookup as wfActor'. inv wfActor'.
      constructors...
      * eapply wf_queue_heapUpdate...
        crush.
      * hauto.
  + Case "ENew".
    eapply wf_actors_heapExtend in Hlookup...
    constructors; crush.
    - remember (O' n) as lkp.
      destruct lkp as[id''|]...
      symmetry in Heqlkp.
      eapply wfO in Heqlkp as Hfoo.
      inverts Hfoo as [Hlt HLH].
      eapply ownerMap_fresh in Heqlkp... omega.
    - repeat constructors...
  + Case "ENew".
    hauto.
    - eapply wfActors in H9 as wfActor'. inv wfActor'.
      constructors...
      * crush.
      * assert (l' <> n).
          eapply local_heap_fresh'...
          unfolds. rewrite H9...
        case_extend.
      * eapply wf_queue_heapUpdate...
        ++ introv Hlookup.
           eapply wfActors in Hlookup as wfActor'.
           inv wfActor'...
           constructors...
           -- assert (l0 <> n).
                eapply local_heap_fresh'...
                unfolds. rewrite Hlookup...
                case_extend.
           -- introv HIn. eapply H2 in HIn as []...
              constructors...
              ** introv HIn.
                 eapply H16 in HIn as []...
                 splits...
                 assert (l1 <> n).
                   eapply local_heap_fresh'...
                   unfolds. rewrite Hlookup...
                case_extend.
              ** introv HIn.
                 eapply H18 in HIn as [id'' HO].
                 exists id''.
                 eapply wfO in HO as Hand.
                 inv Hand as [Hlt HLH].
                 eapply heapLookup_lt in Hlt as [[[[? ?L] ?] ?] Hlookup'].
                 assert (l1 <> n).
                   eapply local_heap_fresh'...
                   unfolds. rewrite Hlookup'...
                   eapply HLH. unfolds; hauto.
                 case_extend.
           -- introv HIn.
              apply H14 in HIn as [id'' HO].
              exists id''.
              eapply wfO in HO as Hand.
              inv Hand as [Hlt HLH].
              eapply heapLookup_lt in Hlt as [[[[? ?L] ?] ?] Hlookup'].
              assert (l'0 <> n).
                eapply local_heap_fresh'...
                unfolds. rewrite Hlookup'...
                eapply HLH. unfolds; hauto.
              case_extend.
        ++ introv HIn.
           eapply H6 in HIn as wfMsg.
           inv wfMsg.
           constructors...
           -- introv HIn'. eapply H1 in HIn' as []...
              splits...
              ** eapply in_cons...
              ** assert (l0 <> n).
                   eapply local_heap_fresh'...
                   unfolds. rewrite H9...
                 case_extend.
           -- introv HIn'.
              apply H3 in HIn' as [id'' HO].
              exists id''.
              eapply wfO in HO as Hand.
              inv Hand as [Hlt HLH].
              eapply heapLookup_lt in Hlt as [[[[? ?L] ?] ?] Hlookup'].
              assert (l0 <> n).
                eapply local_heap_fresh'...
                unfolds. rewrite Hlookup'...
                eapply HLH. unfolds; hauto.
              case_extend.
        ++ crush.
      * crush.
      * hauto.
      * introv HIn.
        eapply H11 in HIn as [id'' HO].
        exists id''.
        eapply wfO in HO as Hand.
        inv Hand as [Hlt HLH].
        eapply heapLookup_lt in Hlt as [[[[? ?L] ?] ?] Hlookup'].
        assert (l'0 <> n).
          eapply local_heap_fresh'...
          unfolds. rewrite Hlookup'...
          eapply HLH. unfolds; hauto.
        case_extend.
    - eapply wfActors in Hlookup as wfActor'.
      inv wfActor'.
      constructors...
      * assert (l' <> n).
        eapply local_heap_fresh'...
        unfolds. rewrite Hlookup...
        case_extend.
      * eapply wf_queue_heapUpdate...
        ++ introv Hlookup'.
           eapply wfActors in Hlookup' as wfActor'.
           inv wfActor'...
           constructors...
           -- assert (l1 <> n).
                eapply local_heap_fresh'...
                unfolds. rewrite Hlookup'...
                case_extend.
           -- introv HIn. eapply H2 in HIn as []...
              constructors...
              ** introv HIn.
                 eapply H16 in HIn as []...
                 splits...
                 assert (l2 <> n).
                   eapply local_heap_fresh'...
                   unfolds. rewrite Hlookup'...
                case_extend.
              ** introv HIn.
                 eapply H18 in HIn as [id'' HO].
                 exists id''.
                 eapply wfO in HO as Hand.
                 inv Hand as [Hlt HLH].
                 eapply heapLookup_lt in Hlt as [[[[? ?L] ?] ?] Hlookup''].
                 assert (l2 <> n).
                   eapply local_heap_fresh'...
                   unfolds. rewrite Hlookup''...
                   eapply HLH. unfolds; hauto.
                 case_extend.
           -- introv HIn.
              eapply H14 in HIn as [id'' HO].
              exists id''.
              eapply wfO in HO as Hand.
              inv Hand as [Hlt HLH].
              eapply heapLookup_lt in Hlt as [[[[? ?L] ?] ?] Hlookup''].
              assert (l'0 <> n).
                eapply local_heap_fresh'...
                unfolds. rewrite Hlookup''...
                eapply HLH. unfolds; hauto.
              case_extend.
        ++ introv HIn.
           eapply H6 in HIn as wfMsg.
           inv wfMsg.
           constructors...
           -- introv HIn'. eapply H1 in HIn' as []...
              splits...
              assert (l1 <> n).
                eapply local_heap_fresh'...
                unfolds. rewrite Hlookup...
              case_extend.
           -- introv HIn'.
              apply H3 in HIn' as [id'' HO].
              exists id''.
              eapply wfO in HO as Hand.
              inv Hand as [Hlt HLH].
              eapply heapLookup_lt in Hlt as [[[[? ?L] ?] ?] Hlookup'].
              assert (l1 <> n).
                eapply local_heap_fresh'...
                unfolds. rewrite Hlookup'...
                eapply HLH. unfolds; hauto.
              case_extend.
        ++ crush.
      * hauto.
      * introv HIn.
        apply H11 in HIn as [id'' HO].
        exists id''.
        eapply wfO in HO as Hand.
        inv Hand as [Hlt HLH].
        eapply heapLookup_lt in Hlt as [[[[? ?L] ?] ?] Hlookup'].
        assert (l'0 <> n).
          eapply local_heap_fresh'...
          unfolds. rewrite Hlookup'...
          eapply HLH. unfolds; hauto.
        case_extend.
Qed.

Lemma wf_heap_preservation :
  forall id O O' H H' n n' e e' l L Q,
    id / (O, H, n); e ==> (O', H', n'); e' ->
    wf_ownerMap O H ->
    wf_heap O H ->
    (forall L id, LH H id = Some L -> Forall (fun l => l < n) L) ->
    wf_actor O H (l, L, Q, e) ->
    wf_heap O' H'.
Proof with eauto using step_id_lt.
  introv Hstep wfO wfH Hfresh wfActor.
  constructors...
  + Case "Preservation of disjointness".
    inverts wfH as Hdisj _.
    introv Hneq HLH1 HLH2 HIn.
    eapply step_id_lt in HLH1 as HId1...
    eapply step_id_lt in HLH2 as HId2...
    inv HId1...
    - inv HId2...
      * heap_case id1 id.
        ++ eapply step_local_heap_neq in HLH2...
           assert (exists L, LH H id = Some L) as Hex.
             remember (LH H id) as lkp.
             unfolds LH. eapply heapLookup_lt in H0 as [[[[? ?] ?] ?] Hlookup].
             rewrite Hlookup in Heqlkp. destruct lkp...
           inv Hex as [L' HLH].
           eapply step_allocates_n in HLH as Halloc...
           inv Halloc...
           -- unfolds LH. rewrite_and_invert...
           -- unfolds LH. rewrite_and_invert.
              inv HIn...
              introv contra. eapply Hfresh in HLH2.
              rewrite Forall_forall in HLH2. eapply HLH2 in contra.
              omega.
        ++ eapply step_local_heap_neq in HLH1...
           heap_case id2 id.
           -- assert (exists L, LH H id = Some L) as Hex.
                remember (LH H id) as lkp.
                unfolds LH. eapply heapLookup_lt in H1 as [[[[? ?] ?] ?] Hlookup].
                rewrite Hlookup in Heqlkp. destruct lkp...
           inv Hex as [L' HLH].
           eapply step_allocates_n in HLH as Halloc...
           inv Halloc...
           ** unfolds LH. rewrite_and_invert...
           ** unfolds LH. rewrite_and_invert.
              introv contra. inv contra...
              +++ eapply Hfresh in HLH1.
                  rewrite Forall_forall in HLH1. eapply HLH1 in HIn.
                  omega.
              +++ eapply Hdisj...
           -- eapply step_local_heap_neq in HLH2...
      * inv H1... heap_case id1 id.
        ++ folds (LH H' id). erewrite step_single_allocation in HLH1...
           contra... eapply Hfresh in HLH1...
           rewrite Forall_forall in HLH1. apply HLH1 in HIn.
           omega.
        ++ eapply step_local_heap_neq in HLH1...
           eapply Hfresh in HLH1.
           introv contra. inv contra...
           rewrite Forall_forall in HLH1.
           eapply HLH1 in HIn... omega.
    - inv H0. inv HIn...
      inv HId2 as [|[]]...
      erewrite step_single_allocation in HLH2...
      introv contra. eapply Hfresh in HLH2.
      rewrite Forall_forall in HLH2. apply HLH2 in contra...
      omega.
  + Case "Preservation of actors".
    introv Hlookup.
    destruct a as [[[l' L'] Q'] e''].
    eapply wf_actor_preservation...
Qed.

Lemma actor_locs_preservation :
  forall id O O' H H' n n' e e' e'' l l' L L' Q Q',
    id / (O, H, n); e ==> (O', H', n'); e' ->
    wf_ownerMap O H ->
    LH H id = Some L ->
    wf_actor O H (l, L, Q, e) ->
    heapLookup H' id = Some (l', L', Q', e'') ->
    (forall l, In l (freeLocs e') -> In l L').
Proof with eauto using is_econtext, in_or_app.
  introv Hstep wfO HLH wfActor Hlookup HIn.
  assert (forall l' : loc, In l' (freeLocs e) -> In l' L) as Hloc
      by (inv wfActor; eauto).
  assert (id < length H') as Hlt...
  assert (forall L'' l, LH H id = Some L'' -> In l L'' -> In l L') as Hmono.
    introv HLH' HIn'. eapply monotonic_local_heap...
    unfolds LH; crush.
  gen e'. gen e''. gen H. gen L.
  expr_cases (induction e) Case;
    intros; inv Hstep; simpls;
    try inv_ctx;
    try rewrite_and_invert;
    try contradiction;
    simpls...
  + Case "EApp".
    eapply wf_actor_ctx with (ctx := ctx_appl e2) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn...
  + Case "EApp".
    eapply wf_actor_ctx with (ctx := ctx_appr e1) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn...
  + Case "EApp".
    unfolds LH. rewrite Hlookup in HLH. inv HLH...
    eapply freeLocs_subst_in in HIn.
    inv HIn...
  + Case "ESend".
    eapply wf_actor_ctx with (ctx := ctx_send v t e2) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn...
  + Case "ESend".
    eapply in_app_or in HIn...
    inv HIn... inv H; try contradiction...
    eapply wfO in H12 as []...
  + Case "EMut".
    eapply wf_actor_ctx in wfActor as wfActor'...
  + Case "ENew".
    inv HIn... hauto.
    constructors...
Qed.

Lemma actor_ids_preservation :
  forall id O O' H H' n n' e e' l L Q,
    id / (O, H, n); e ==> (O', H', n'); e' ->
    wf_actor O H (l, L, Q, e) ->
    (forall id, In id (freeIds e') -> id < length H').
Proof with eauto using is_econtext, in_or_app, monotonic_heap.
  introv Hstep wfActor HIn.
  assert (length H <= length H') as Hlt'...
  assert (forall id, In id (freeIds e) -> id < length H) as HId
      by (inverts wfActor; eauto).
  gen e'. gen H. gen L.
  expr_cases (induction e) Case;
    intros; inv Hstep; simpls;
    try inv_ctx;
    try rewrite_and_invert;
    try contradiction;
    simpls...
  + Case "EApp".
    eapply wf_actor_ctx with (ctx := ctx_appl e2) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn... assert (id0 < length H)... omega.
  + Case "EApp".
    eapply wf_actor_ctx with (ctx := ctx_appr e1) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn... assert (id0 < length H)... omega.
  + Case "EApp".
    eapply freeIds_subst_in in HIn.
    inv HIn...
  + Case "ESend".
    eapply wf_actor_ctx with (ctx := ctx_send v t e2) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn... assert (id0 < length H)... omega.
  + Case "ESend".
    rewrite app_nil_r in HIn...
  + Case "EMut".
    eapply wf_actor_ctx in wfActor as wfActor'...
  + Case "ENew".
    inv HIn; try contradiction...
    hauto.
Qed.

Lemma actor_tids_preservation :
  forall id O O' H H' n n' e e' e'' l l' L L' Q Q',
    id / (O, H, n); e ==> (O', H', n'); e' ->
    wf_ownerMap O H ->
    wf_actor O H (l, L, Q, e) ->
    heapLookup H' id = Some (l', L', Q', e'') ->
    (forall L id, LH H id = Some L -> Forall (fun l => l < n) L) ->
    (forall l,
        In l (freeTIds e') ->
        exists id,
          O' l = Some id).
Proof with eauto using is_econtext, in_or_app, monotonic_heap, step_local_heap_neq.
  introv Hstep wfO wfActor Hlookup Hfresh HIn.
  gen e'. gen e''. gen L.
    expr_cases (induction e) Case;
    intros; inv Hstep; simpls;
    try inv_ctx;
    try rewrite_and_invert;
    try contradiction;
    simpls...
  + Case "EApp".
    eapply wf_actor_ctx with (ctx := ctx_appl e2) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn...
    inv wfActor...
    specializes H12 l0 ___...
    inv H12 as [id' HO].
    exists id'.
    eapply ownerMap_monotonic with (l := l0) in H10...
    rewrite <- H10...
    eapply ownerMap_fresh...
  + Case "EApp".
    eapply wf_actor_ctx with (ctx := ctx_appr e1) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn...
    inv wfActor...
    specializes H13 l0 ___...
    inv H13 as [id' HO].
    exists id'.
    eapply ownerMap_monotonic with (l := l0) in H10...
    rewrite <- H10...
    eapply ownerMap_fresh...
  + Case "EApp".
    inv wfActor.
    eapply freeTIds_subst_in in HIn.
    inv HIn; simpls...
  + Case "ESend".
    eapply wf_actor_ctx with (ctx := ctx_send v t e2) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn...
    inv wfActor...
    specializes H12 l0 ___...
    inv H12 as [id' HO].
    exists id'.
    eapply ownerMap_monotonic with (l := l0) in H10...
    rewrite <- H10...
    eapply ownerMap_fresh...
  + Case "ESend".
    rewrite app_nil_r in HIn...
    inv wfActor.
    specializes H9 l0 ___...
  + Case "EMut".
    eapply wf_actor_ctx in wfActor...
  + Case "ENew".
    inv HIn; try contradiction.
    rewrite extend_eq...
Qed.

Lemma fresh_preservation :
  forall id id' O O' H H' n n' e e' L,
    id / (O, H, n); e ==> (O', H', n'); e' ->
    (forall id' L, LH H id' = Some L -> Forall (fun l => l < n) L) ->
    LH H' id' = Some L ->
    Forall (fun l => l < n') L.
Proof with hauto.
  introv Hstep Hfresh HLH.
  gen e'.
  expr_cases (induction e) Case;
    intros; inv Hstep; simpls;
    try inv_ctx...
  + Case "ESend".
    eapply Hfresh...
    crush.
  + Case "ESend".
    eapply Hfresh...
    crush.
  + Case "ENew".
    rewrite Forall_forall. introv HIn.
    inv HIn... assert (x < n)...
    assert (LH H id' = Some L0) as HLH
        by (unfolds LH; rewrite H9; eauto).
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "ENew".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "ENew".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "ENew".
    rewrite Forall_forall. introv HIn.
    inv HIn... assert (x < n)...
    assert (LH H id' = Some L0) as HLH
        by (unfolds LH; rewrite H9; eauto).
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "ENew".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
Qed.

Theorem preservation :
  forall id cfg cfg',
    wf_cfg cfg ->
    step id cfg cfg' ->
    wf_cfg cfg'.
Proof with eauto.
  introv wfCfg Hstep.
  inv wfCfg as [O H n wfH wfO Hfresh].
  inverts wfH as Hdisj wfActors.
  inverts wfO as wfO.
  inv Hstep.
  + Case "EvalActorMsg".
    constructors.
    - constructors.
      * SCase "LH".
        introv Hneq HLH1 HLH2 HIn.
        repeat hauto.
        ++ eapply Hdisj...
           rewrite H5...
        ++ eapply Hdisj...
           rewrite H5...
      * SCase "wfActor".
        introv Hlookup.
        hauto.
        ++ SSCase "id = id0".
           assert (wf_actor O H (l, L, v' :: Q, v)) as wfActor...
           inverts wfActor as Hthis HOthis wfQueue Hex Hloc HId HTId.
           assert (In v' (v' :: Q)) as wfMsg
               by (constructors; eauto).
           apply wfQueue in wfMsg.
           constructors...
           -- unfolds wf_queue.
              introv HIn.
              assert (In msg (v' :: Q)) as HIn'
                  by eauto using in_cons.
              apply wfQueue in HIn' as wfMsg'.
              inverts wfMsg' as Hex' Hloc' HId' HTId'.
              constructors; hauto.
           -- unfolds wf_queue.
              inverts wfMsg as [t hasType] Hloc' HId' HTId'.
              exists t. repeat constructors...
           -- inv wfMsg. introv HIn. simpls.
              apply in_app_or in HIn.
              inv HIn... eapply H1 in H4 as []...
              inv H4... contradiction.
           -- inv wfMsg. rewrite heapUpdate_length...
              introv HIn. simpls.
              apply in_app_or in HIn.
              inv HIn... simpls. contradiction.
           -- inverts wfMsg as Hex' Hloc' HId' HTId'.
              introv HIn'. simpls.
              apply in_app_or in HIn'.
              inv HIn'; try contradiction...
        ++ SSCase "id <> id0".
           destruct a as [[[l' L'] Q'] e'].
           assert (wf_actor O H (l', L', Q', e')) as wfActor...
           inverts wfActor as Hthis HOthis wfQueue Hex Hloc HId HTId.
           constructors; hauto.
           -- unfolds wf_queue.
              introv HIn.
              apply wfQueue in HIn as wfMsg.
              inverts wfMsg as Hex' Hloc' HId' HTId'.
              constructors; hauto.
    - SCase "Owner map is well-formed".
      eapply wf_ownerMap_heapUpdate...
      constructors...
      unfolds; hauto.
    - SCase  "Freshness is preserved".
      introv HLH'. unfolds LH.
      hauto.
      apply Hfresh with (id := id0).
      rewrite H5...
  + Case "EvalActorTransfer".
    constructors.
    - SCase "Heap is well-formed".
      constructors.
      * introv Hneq HLH1 HLH2 HIn.
        ++ destruct (id_eq_dec id' id2); subst.
           -- unfolds LH. heap_rewrite; try rewrite heapUpdate_length...
              repeat heap_rewrite. inv_eq...
              contra.
              ** eapply wfO in H6 as [Hlt HLH].
                 hauto.
                 +++ apply remove_in_eq in HIn...
                 +++ assert (In l0 L)...
                     eapply Hdisj... rewrite H4...
              ** hauto.
                 +++ apply remove_in in HIn.
                     eapply Hdisj with (L1 := L)...
                     rewrite H4... rewrite H9...
                 +++ eapply Hdisj with (id1 := id1) (L1 := L1) (L2 := L')...
                     rewrite H9...
           -- destruct (id_eq_dec id' id1); subst...
              ** unfolds LH. heap_rewrite; try rewrite heapUpdate_length...
                 inv_eq. destruct (id_eq_dec id id1); subst...
                 heap_rewrite; try rewrite heapUpdate_length...
                 hauto.
                 +++ inv HIn...
                     --- eapply remove_in_eq...
                     --- introv contra.
                         apply remove_in in contra.
                         eapply Hdisj with (id1 := id2) (L2 := L')...
                         rewrite H4...
                         rewrite H9...
                 +++ inv HIn...
                     --- eapply wfO in H6 as [Hlt HLH].
                         rewrite H4 in HLH.
                         eapply Hdisj with (L1 := L)...
                         rewrite H4...
                     --- eapply Hdisj with (id1 := id1)...
                         rewrite H9...
              ** unfolds LH. heap_rewrite; try rewrite heapUpdate_length...
                 destruct (id_eq_dec id id1); subst...
                 +++ heap_rewrite; try rewrite heapUpdate_length...
                     hauto.
                     eapply remove_in in HIn.
                     eapply Hdisj with (id1 := id1) (L1 := L)...
                     rewrite H4...
                 +++ heap_rewrite; try rewrite heapUpdate_length...
                     hauto.
                     introv contra.
                     apply remove_in in contra.
                     eapply Hdisj with (id1 := id2) (L2 := L1)...
                     rewrite H4...
      * (* This is a horrible jumble of copy-paste... *)
        introv Hlookup.
        eapply wfActors in H4 as wfActor.
        eapply wfActors in H9 as wfActor'.
        inverts wfActor as Hthis HOthis wfQueue Hex Hloc HId HTId.
        inverts wfActor' as Hthis' HOthis' wfQueue' Hex' Hloc' HId' HTId'.
        destruct (id_eq_dec id' id0); subst.
        ++ heap_rewrite; try rewrite heapUpdate_length...
           inv_eq. constructors...
           -- crush.
           -- case_extend.
           -- introv HIn.
              eapply wfQueue' in HIn as wfMsg.
              inverts wfMsg as mHex mHloc mHId mHTId.
              constructors...
              ** introv HIn'.
                 eapply mHloc in HIn' as []...
                 crush.
              ** hauto.
              ** introv HIn'.
                 specializes mHTId l0 ___.
                 inv mHTId as [id' HO]...
                 destruct (id_eq_dec id id0); subst; case_extend...
           -- crush.
           -- hauto.
           -- introv HIn'.
              specializes HTId' l' ___.
              inv HTId' as [id' HO]...
              case_extend...
        ++ heap_rewrite. hauto.
           -- constructors; simpls; try contradiction...
              ** eapply remove_in_neq...
                 introv contra. congruence.
              ** case_extend.
              ** introv HIn.
                 eapply wfQueue in HIn as wfMsg.
                 inverts wfMsg as mHex mHloc mHId mHTId.
                 constructors...
                 +++ introv HIn'.
                     eapply mHloc in HIn' as [].
                     split.
                     --- eapply remove_in_neq...
                         introv contra. congruence.
                     --- case_extend.
                 +++ hauto.
                 +++ introv HIn'.
                     specializes mHTId l0 ___.
                     inv mHTId as [id'' HO]...
                     case_extend...
              ** exists TUnit. constructors...
           -- eapply wfActors in Hlookup as wfActor.
              inverts wfActor as Hthis'' HOthis'' wfQueue'' Hex'' Hloc'' HId'' HTId''.
              constructors...
              ** case_extend.
              ** introv HIn.
                 eapply wfQueue'' in HIn as wfMsg.
                 inverts wfMsg as mHex mHloc mHId mHTId.
                 constructors...
                 +++ introv HIn'.
                     eapply mHloc in HIn' as [].
                     split... case_extend.
                 +++ hauto.
                 +++ introv HIn'.
                     specializes mHTId l0 ___.
                     inv mHTId as [id'' HO]...
                     case_extend...
              ** hauto.
              ** introv HIn'.
                 specializes HTId'' l' ___.
                 inv HTId'' as [id'' HO]...
                 case_extend...
    - SCase "Owner map is well-formed".
      constructors.
      introv HO. repeat rewrite heapUpdate_length... splits...
      * hauto. unfold extend in HO.
        cases_if; try inv_eq...
        eapply wfO in HO as []...
      * introv HLH.
        destruct (id_eq_dec id' id0); subst.
        ++ unfolds LH. heap_rewrite; try rewrite heapUpdate_length...
           inv_eq...
           eapply wfO in H6 as [Hlt HLH].
           hauto. unfold extend in HO.
           cases_if...
           ** constructors...
           ** apply in_cons.
              specializes wfO l0 id0 ___...
              inv wfO as [Hlt' HLH'].
              eapply HLH'. hauto.
        ++ unfold extend in HO.
           cases_if...
           specializes wfO l0 id0 ___.
           inv wfO... unfolds LH.
           heap_rewrite. hauto.
           eapply remove_in_neq...
    - SCase "Freshness is preserved".
      introv HLH.
      assert (l < n).
        eapply ownerMap_fresh...
        constructors...
      destruct (id_eq_dec id' id0); subst.
      * unfolds LH. heap_rewrite; try rewrite heapUpdate_length...
        inv_eq. eapply wfO in H6 as [Hlt HLH'].
        specializes Hfresh L' id0 ___; hauto.
      * destruct (id_eq_dec id' id0); subst.
        ++ unfolds LH. heap_rewrite; try rewrite heapUpdate_length...
           inv_eq...
           eapply wfO in H6 as [Hlt HLH].
           specializes Hfresh L' id0 ___; hauto.
        ++ unfolds LH. repeat heap_rewrite.
           heap_case id id0.
           rewrite Forall_forall.
           introv HIn. eapply remove_in in HIn...
           specializes Hfresh L id0 ___; hauto.
           rewrite Forall_forall in Hfresh...
  + Case "EvalActorRun".
    assert (wf_actor O H (l, L, Q, e)) as wfActor...
    inverts wfActor as Hthis HOthis wfQueue (t & hasType) Hloc HId HBId.
    assert (wf_heap O' H') as wfH'.
      eapply wf_heap_preservation...
      constructors...
      constructors...
    constructors.
    - assert (forall id1 id2 L1 L2,
                 id1 <> id2 ->
                 LH H' id1 = Some L1 ->
                 LH H' id2 = Some L2 ->
                 (forall l : loc, In l L1 -> ~ In l L2)) as Hdisj'
          by (inverts wfH' as (? & ?); eauto).
      eapply wf_heap_heapUpdate; try omega...
      assert (wf_actor O' H' (l, L', Q', e'')) as wfActor
          by (inverts wfH' as [_ ?]; eauto).
      eapply type_preservation in hasType...
      constructors...
      * inv wfActor...
      * eapply ownerMap_monotonic with (l := l) in H6...
        rewrite <- H6...
        specializes Hfresh L id ___.
          unfolds LH; hauto.
        rewrite Forall_forall in Hfresh...
      * eapply wf_queue_preservation...
        constructors... constructors... constructors...
      * eapply actor_locs_preservation...
        constructors...
        unfolds LH. crush.
      * eapply actor_ids_preservation...
      * eapply actor_tids_preservation...
        constructors...
    - eapply wf_ownerMap_preservation in H6...
      eapply wf_ownerMap_heapUpdate...
      unfolds; hauto.
      constructors... constructors... constructors...
    - introv HLH'. rewrite Forall_forall. introv HIn.
      unfolds LH. hauto.
      * eapply fresh_preservation with (id' := id0) (L := L0) in H6...
        rewrite Forall_forall in H6...
        unfolds. rewrite H7...
      * eapply fresh_preservation in H6...
        rewrite Forall_forall in H6...
Qed.