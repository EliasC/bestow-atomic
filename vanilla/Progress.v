Require Import SyntaxProp.
Require Import StaticProp.
Require Import DynamicProp.
Require Import WellFormednessProp.

Lemma actor_progress :
  forall H n l L Q e id,
    wf_cfg (H, n) ->
    wf_actor H (l, L, Q, e) ->
    id < length H ->
    (exists H' n' e', id / (H, n) ; e ==> (H', n') ; e') \/ is_val e.
Proof with eauto using is_val, step_actor, is_econtext.
  introv wfCfg wfActor wfId.
  assert (exists t, empty |- e \in t) as [t hasType].
    inv wfActor...
  remember empty as Gamma.
  hasType_cases(induction hasType) Case; subst...
  + Case "T_Var".
    inv Hlookup.
  + Case "T_NewPassive".
    left. find_actor id...
  + Case "T_Mutate".
    apply wf_actor_ctx in wfActor...
    crush.
    - left. repeat constructors...
    - inv H0; inv hasType...
  + Case "T_Bestow".
    apply wf_actor_ctx in wfActor...
    crush.
    - left. repeat constructors...
    - inv H0; inv hasType...
  + Case "T_Apply".
    assert (wf_actor H (l, L, Q, e1)) as wfActor'.
    apply wf_actor_ctx with (ctx := ctx_appl e2)...
    crush.
    - left. apply EvalContext with (ctx := ctx_appl e2) in H0...
    - apply wf_actor_ctx
       with (ctx := ctx_appr e1)
         in wfActor as wfActor''...
      crush.
      * left. apply EvalContext with (ctx := ctx_appr e1) in H1...
      * inv H0; try solve[inv hasType1]...
        constructors...
  + Case "T_Send".
    eapply wf_actor_ctx
      with (ctx := ctx_send x TPas e')
        in wfActor as wfActor'...
    crush.
    - left. apply EvalContext with (ctx := ctx_send x TPas e') in H1...
    - unfold is_active in Hactive.
      destruct a; inv Hactive.
      * SCase "ActorSend".
        left. inv H1; try solve[inv hasType1]...
        inv wfActor'. simpls.
        assert (id0 < length H) as Hlt...
        find_actor id0...
      * SCase "BestowedSend".
        left. inv H1; try solve[inv hasType1]...
        inverts wfActor' as Hthis wfQueue Hex Hloc HId HBId.
        simpls.
        specializes HBId l0 id0 ___.
        inv HBId as (Hlt & Hloc')...
        find_actor id0...
Qed.

Theorem progress :
  forall H n id,
    wf_cfg (H, n) ->
    id < length H ->
    (exists cfg', step id (H, n) cfg') \/ actor_done (H, n) id.
Proof with eauto using step_preserves_this.
  introv wfCfg Hlt.
  find_actor id.
  assert (wf_actor H (l, L, Q, e)) as wfActor.
    inverts wfCfg as wfH. inverts wfH as [_ wfActors]...
  eapply actor_progress in wfCfg...
  inv wfCfg as [Hex | Hdone].
  + Case "e steps".
    left.
    inv Hex as [H' [n' [e' Hstep]]].
    assert (exists L' Q' e'', heapLookup H' id = Some (l, L', Q', e'')) as Hlookup'...
    destruct Hlookup' as [? [? [? ?]]].
    eapply EvalActorRun in Hstep...
  + Case "is_val e".
    destruct Q.
    - SCase "Q empty".
      right.
      unfolds. rewrite Hlookup.
      constructors...
    - SCase "Q non-empty".
      left.
      exists (heapUpdate H id (l, L, Q, EApp e0 (ELoc l)), n).
      constructors...
Qed.
