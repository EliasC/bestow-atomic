Require Import SyntaxProp.
Require Import StaticProp.
Require Import DynamicProp.
Require Import WellFormednessProp.

Require Import MapProp.

Hint Unfold subst.

Lemma type_preservation :
  forall id H H' n n' e e' t,
    empty |- e \in t ->
    id / (H, n); e ==> (H', n'); e' ->
    empty |- e' \in t.
Proof with eauto using hasType_subst.
  introv hasType Hstep. gen e'.
  remember empty as Gamma.
  hasType_cases(induction hasType) Case; intros; inv Hstep;
  try solve[inv_ctx; constructors; eauto];
  try constructors.
  inv hasType1...
Qed.

Lemma wf_queue_preservation :
  forall id id' H H' n n' e e' e'' l l' L L' Q Q',
    id / (H, n); e ==> (H', n'); e' ->
    wf_actor H (l, L, Q, e) ->
    (forall id a, heapLookup H id = Some a -> wf_actor H a) ->
    heapLookup H' id' = Some (l', L', Q', e'') ->
    wf_queue H' L' Q'.
Proof with eauto using is_econtext.
  introv Hstep wfActor wfActors Hlookup.
  assert (id' < length H') as Hlt...
  assert (forall L'' l, LH H id' = Some L'' -> In l L'' -> In l L') as Hmono.
    introv HLH HIn. eapply monotonic_local_heap...
    hauto.
  gen e'. gen H.
  expr_cases (induction e) Case;
    intros; inv Hstep; simpls;
    try inv_ctx;
    try rewrite_and_invert...
  + Case "EApp". eapply wf_actor_ctx with (ctx := ctx_appl e2) in wfActor...
  + Case "EApp". eapply wf_actor_ctx with (ctx := ctx_appr e1) in wfActor...
  + Case "EApp". apply wfActors in Hlookup... inv Hlookup...
  + Case "ESend". eapply wf_actor_ctx with (ctx := ctx_send v t e2) in wfActor...
  + Case "ESend".
    hauto.
    - eapply wfActors in H10 as wfActor'. inv wfActor'.
      find_actor id'.
      eapply wf_queue_heapUpdate in Hlookup...
      * eapply wf_queue_snoc...
        inverts wfActor as [t hasType].
        constructors; simpls...
        ++ inv hasType...
        ++ inv hasType... introv contra.
           rewrite H18 in *. inv contra.
      * introv HIn. eapply Hmono...
        hauto.
    - eapply wfActors in Hlookup as wfActor'.
      introv HIn.
      inverts wfActor' as Hthis wfQueue Hex Hloc HId HBId.
      eapply wfQueue in HIn as wfMsg.
      inverts wfMsg as Hex' Hloc' HId' HBId'.
      constructors; hauto.
      introv HIn'. apply HBId' in HIn' as [Hlt' HBloc].
      splits...
      hauto.
  + Case "ESend".
    hauto.
    - eapply wfActors in H10 as H'. inv H'.
      eapply wf_queue_heapUpdate in H10...
      eapply wf_queue_snoc...
      inverts wfActor as [t hasType].
      constructors; simpls...
      ++ inv hasType...
         eexists... repeat constructors...
         eapply hasType_subsumption...
         introv HIn.
         case_extend...
         eapply free_in_env in HIn as [t' contra]...
         rewrite extend_neq in contra...
         unfolds activeEnv... simpls...
      ++ inv hasType... introv HIn.
         rewrite H18 in HIn. simpls.
         inv HIn; try contradiction...
         specializes H17 l1 id' ___.
         inv H17 as (_ & Hloc).
         apply Hloc... unfolds. rewrite H10...
      ++ rewrite app_nil_r...
      ++ rewrite app_nil_r...
    - eapply wfActors in Hlookup.
      unfolds. introv HIn.
      inv Hlookup...
      eapply H5 in HIn as wfMsg.
      inv wfMsg...
      constructors; hauto.
      introv HIn'. apply H3 in HIn' as [Hlt' HBloc]. splits...
      introv HLH. hauto.
  + Case "EMut". eapply wf_actor_ctx with (ctx := ctx_mut) in wfActor...
  + Case "EMut". apply wfActors in Hlookup... inv Hlookup...
  + Case "ENew".
    hauto.
    - eapply wfActors in H7 as wfActor'.
      inverts wfActor' as Hthis wfQueue Hex Hloc HId HBId.
      eapply wf_queue_heapUpdate in H7...
      introv HIn. apply wfQueue in HIn as wfMsg.
      inv wfMsg. constructors; crush...
    - eapply wfActors in Hlookup as wfActor'.
      inverts wfActor' as Hthis wfQueue Hex Hloc HId HBId.
      introv HIn. eapply wfQueue in HIn as wfMsg.
      inv wfMsg. constructors; hauto.
      introv HIn'. eapply H3 in HIn' as [Hlt' HBloc].
      splits...
      introv HLH. hauto.
      apply in_cons...
  + eapply wf_actors_heapExtend in Hlookup...
    - inv Hlookup...
    - constructors; crush.
      repeat constructors.
  + eapply wf_actor_ctx with (ctx := ctx_bes) in wfActor...
  + apply wfActors in Hlookup... inv Hlookup...
Qed.

Lemma wf_heap_preservation :
  forall id H H' n n' e e' l L Q,
    id / (H, n); e ==> (H', n'); e' ->
    wf_heap H ->
    (forall L id, LH H id = Some L -> Forall (fun l => l < n) L) ->
    wf_actor H (l, L, Q, e) ->
    wf_heap H'.
Proof with eauto using step_id_lt.
  introv Hstep wfH Hfresh wfActor.
  constructors...
  + inverts wfH as Hdisj _.
    introv Hneq HLH1 HLH2 HIn.
    eapply step_id_lt in HLH1 as HId1...
    eapply step_id_lt in HLH2 as HId2...
    inv HId1...
    - inv HId2...
      * heap_case id1 id.
        ++ eapply step_local_heap_neq in HLH2...
           assert (exists L, LH H id = Some L) as Hex.
             remember (LH H id) as lkp.
             find_actor id.
             unfolds LH. rewrite Hlookup in Heqlkp. destruct lkp...
           inv Hex as [L' HLH].
           eapply step_allocates_n in HLH as Halloc...
           inv Halloc...
           -- unfolds LH. rewrite_and_invert...
           -- unfolds LH. rewrite_and_invert.
              inv HIn...
              introv contra. eapply Hfresh in HLH2.
              rewrite Forall_forall in HLH2. eapply HLH2 in contra.
              omega.
        ++ eapply step_local_heap_neq in HLH1...
           heap_case id2 id.
           -- assert (exists L, LH H id = Some L) as Hex.
                remember (LH H id) as lkp.
                unfolds LH. find_actor id.
                rewrite Hlookup in Heqlkp. destruct lkp...
           inv Hex as [L' HLH].
           eapply step_allocates_n in HLH as Halloc...
           inv Halloc...
           ** unfolds LH. rewrite_and_invert...
           ** unfolds LH. rewrite_and_invert.
              introv contra. inv contra...
              +++ eapply Hfresh in HLH1.
                  rewrite Forall_forall in HLH1. eapply HLH1 in HIn.
                  omega.
              +++ eapply Hdisj...
           -- eapply step_local_heap_neq in HLH2...
      * inv H1... heap_case id1 id.
        ++ folds (LH H' id). erewrite step_single_allocation in HLH1...
           contra... eapply Hfresh in HLH1...
           rewrite Forall_forall in HLH1. apply HLH1 in HIn.
           omega.
        ++ eapply step_local_heap_neq in HLH1...
           eapply Hfresh in HLH1.
           introv contra. inv contra...
           rewrite Forall_forall in HLH1.
           eapply HLH1 in HIn... omega.
    - inv H0. inv HIn...
      inv HId2 as [|[]]...
      erewrite step_single_allocation in HLH2...
      introv contra. eapply Hfresh in HLH2.
      rewrite Forall_forall in HLH2. apply HLH2 in contra...
      omega.
  + introv Hlookup.
    destruct_actor a.
    eapply step_footprint in Hstep as Hfootprint...
    constructors...
    - inv Hfootprint as [Hex|[Hunit HIn]]...
      inv Hex as [L'' [Q'' Hlookup']].
      inverts wfH as _ wfActors.
      assert (forall l, In l L'' -> In l L0) as Hmono.
        intros. eapply monotonic_local_heap...
        unfolds. rewrite Hlookup'...
        unfolds. rewrite Hlookup...
      eapply wfActors in Hlookup' as wfActor'...
      inv wfActor'...
    - eapply wf_queue_preservation in Hlookup...
      inv wfH. crush.
    - inv Hfootprint as [Hex|[Hunit HIn]].
      * inv Hex as [L'' [Q'' Hlookup']].
        inverts wfH as [? ?]...
        apply H2 in Hlookup'.
        inv Hlookup'...
      * repeat constructors...
    - inv Hfootprint as [Hex|[Hunit HIn]]...
      * inv Hex as [L'' [Q'' Hlookup']].
        inverts wfH as [? ?]...
        apply H2 in Hlookup' as wfActor'.
        inv wfActor'... introv HIn...
        eapply H9 in HIn.
        eapply monotonic_local_heap...
        ++ unfolds. rewrite Hlookup'...
        ++ unfolds. rewrite Hlookup...
      * crush.
    - inv Hfootprint as [Hex|[Hunit HIn]]...
      * inv Hex as [L'' [Q'' Hlookup']].
        inverts wfH as [? ?]...
        apply H2 in Hlookup' as wfActor'.
        inv wfActor'... introv HIn...
        eapply H10 in HIn...
        eapply monotonic_heap in Hstep...
        omega.
      * crush.
    - inv Hfootprint as [Hex|[Hunit HIn]]...
      * inv Hex as [L'' [Q'' Hlookup']].
        inverts wfH as _ wfActors...
        apply wfActors in Hlookup' as wfActor'.
        inv wfActor'... introv HIn...
        eapply H9 in HIn as [Hlt HBloc].
        splits.
        ++ eapply monotonic_heap in Hstep...
           omega.
        ++ introv HIn'. eapply heapLookup_lt in Hlt.
           inv Hlt as [a Hlookup'']. destruct_actor a.
           assert (forall l, In l L2 -> In l L1) as Hmono.
             intros. eapply monotonic_local_heap; hauto.
           eapply monotonic_local_heap...
           -- hauto.
           -- eapply HBloc... unfolds. rewrite Hlookup''...
      * crush.
Qed.

Lemma actor_locs_preservation :
  forall id H H' n n' e e' e'' l l' L L' Q Q',
    id / (H, n); e ==> (H', n'); e' ->
    LH H id = Some L ->
    wf_actor H (l, L, Q, e) ->
    heapLookup H' id = Some (l', L', Q', e'') ->
    (forall l, In l (freeLocs e') -> In l L').
Proof with eauto using is_econtext, in_or_app.
  introv Hstep HLH wfActor Hlookup HIn.
  assert (forall l' : loc, In l' (freeLocs e) -> In l' L) as Hloc
      by (inv wfActor; eauto).
  assert (id < length H') as Hlt...
  assert (forall L'' l, LH H id = Some L'' -> In l L'' -> In l L') as Hmono.
    introv HLH' HIn'. eapply monotonic_local_heap...
    unfolds LH; crush.
  gen e'. gen e''. gen H. gen L.
  expr_cases (induction e) Case;
    intros; inv Hstep; simpls;
    try inv_ctx;
    try rewrite_and_invert;
    try contradiction;
    simpls...
  + eapply wf_actor_ctx with (ctx := ctx_appl e2) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn...
  + eapply wf_actor_ctx with (ctx := ctx_appr e1) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn...
  + unfolds LH. rewrite Hlookup in HLH. inv HLH...
    eapply freeLocs_subst_in in HIn.
    inv HIn...
  + eapply wf_actor_ctx with (ctx := ctx_send v t e2) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn...
  + eapply wf_actor_ctx in wfActor as wfActor'...
  + inv HIn... hauto.
    constructors...
  + eapply wf_actor_ctx in wfActor as wfActor'...
Qed.

Lemma actor_ids_preservation :
  forall id H H' n n' e e' e'' l l' L L' Q Q',
    id / (H, n); e ==> (H', n'); e' ->
    wf_actor H (l, L, Q, e) ->
    heapLookup H' id = Some (l', L', Q', e'') ->
    (forall id, In id (freeIds e') -> id < length H').
Proof with eauto using is_econtext, in_or_app, monotonic_heap.
  introv Hstep wfActor Hlookup HIn.
  assert (length H <= length H') as Hlt'...
  assert (forall id, In id (freeIds e) -> id < length H) as HId
      by (inverts wfActor; eauto).
  gen e'. gen e''. gen H. gen L.
  expr_cases (induction e) Case;
    intros; inv Hstep; simpls;
    try inv_ctx;
    try rewrite_and_invert;
    try contradiction;
    simpls...
  + eapply wf_actor_ctx with (ctx := ctx_appl e2) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn... assert (id0 < length H)... omega.
  + eapply wf_actor_ctx with (ctx := ctx_appr e1) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn... assert (id0 < length H)... omega.
  + eapply freeIds_subst_in in HIn.
    inv HIn...
  + eapply wf_actor_ctx with (ctx := ctx_send v t e2) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn... assert (id0 < length H)... omega.
  + eapply wf_actor_ctx in wfActor as wfActor'...
  + inv HIn; try contradiction...
    hauto.
  + eapply wf_actor_ctx in wfActor as wfActor'...
Qed.

Lemma actor_bids_preservation :
  forall id H H' n n' e e' e'' l l' L L' Q Q',
    id / (H, n); e ==> (H', n'); e' ->
    LH H id = Some L ->
    wf_actor H (l, L, Q, e) ->
    heapLookup H' id = Some (l', L', Q', e'') ->
    forall l id,
      In (l, id) (freeBIds e') ->
      id < length H' /\
      (forall L : list loc, LH H' id = Some L -> In l L).
Proof with eauto using is_econtext, in_or_app, monotonic_heap, step_local_heap_neq.
  introv Hstep HLH wfActor Hlookup HIn.
  assert (length H <= length H') as Hmono...
  assert (forall l' : loc, In l' (freeLocs e) -> In l' L) as Hloc
      by (inv wfActor; eauto).
  assert (forall l' id0,
             In (l', id0) (freeBIds e) ->
             id0 < length H /\
             forall L, LH H id0 = Some L -> In l' L) as HBId
      by (inverts wfActor; eauto).
  gen e'. gen e''. gen L.
  expr_cases (induction e) Case;
    intros; inv Hstep; simpls;
    try inv_ctx;
    try rewrite_and_invert;
    try contradiction;
    simpls...
  + eapply wf_actor_ctx with (ctx := ctx_appl e2) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn...
    - splits; eapply IHe1 with (L := L)...
    - specializes HBId l0 id0 ___...
      inv HBId.
      splits; try omega.
      introv HLH'. destruct (id_eq_dec id0 id); subst...
      eapply monotonic_local_heap...
  + eapply wf_actor_ctx with (ctx := ctx_appr e1) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn...
    - specializes HBId l0 id0 ___...
      inv HBId.
      splits; try omega.
      introv HLH'. destruct (id_eq_dec id0 id); subst...
      eapply monotonic_local_heap...
    - splits; eapply IHe2 with (L := L)...
  + eapply freeBIds_subst_in in HIn.
    inv HIn...
  + eapply wf_actor_ctx with (ctx := ctx_send v t e2) in wfActor as wfActor'...
    eapply in_app_or in HIn...
    inv HIn...
    - splits; eapply IHe1 with (L := L)...
    - specializes HBId l0 id0 ___...
      inv HBId.
      splits; try omega.
      introv HLH'. destruct (id_eq_dec id0 id); subst...
      eapply monotonic_local_heap...
  + eapply wf_actor_ctx in wfActor as wfActor'...
  + eapply wf_actor_ctx in wfActor as wfActor'...
  + inv HIn; try contradiction...
    inv H... unfolds LH. rewrite Hlookup in HLH.
    inv HLH... splits...
    rewrite Hlookup...
    introv HLH. inv HLH...
Qed.

Lemma fresh_preservation :
  forall id id' H H' n n' e e' L,
    id / (H, n); e ==> (H', n'); e' ->
    (forall id' L, LH H id' = Some L -> Forall (fun l => l < n) L) ->
    LH H' id' = Some L ->
    Forall (fun l => l < n') L.
Proof with hauto.
  introv Hstep Hfresh HLH.
  gen e'.
  expr_cases (induction e) Case;
    intros; inv Hstep; simpls;
    try inv_ctx...
  + Case "ESend".
    eapply Hfresh...
    crush.
  + Case "ESend".
    eapply Hfresh...
    crush.
  + Case "ENew".
    rewrite Forall_forall. introv HIn.
    inv HIn... assert (x < n)...
    assert (LH H id' = Some L0) as HLH
        by (unfolds LH; rewrite H7; eauto).
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "ENew".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
  + Case "ENew".
    rewrite Forall_forall. introv HIn.
    assert (x < n)...
    eapply Hfresh in HLH. rewrite Forall_forall in HLH...
Qed.

Theorem preservation :
  forall id cfg cfg',
    wf_cfg cfg ->
    step id cfg cfg' ->
    wf_cfg cfg'.
Proof with eauto.
  introv wfCfg Hstep.
  inv wfCfg as [H n wfH Hfresh].
  inverts wfH as Hdisj wfActors.
  inv Hstep.
  + Case "EvalActorMsg".
    constructors...
    - constructors.
      * SCase "Disjointness".
        introv Hneq HLH1 HLH2 HIn.
        hauto.
        ++ eapply Hdisj...
           rewrite H3...
        ++ hauto.
           eapply Hdisj...
           rewrite H3...
      * SCase "wfActor".
        introv Hlookup.
        hauto.
        ++ SSCase "id = id0".
           eapply wfActors in H3 as wfActor...
           inverts wfActor as Hthis wfQueue Hex Hloc HId HBId.
           assert (In v' (v' :: Q)) as wfMsg
               by (constructors; eauto).
           apply wfQueue in wfMsg.
           constructors...
           -- unfolds wf_queue.
              introv HIn.
              assert (In msg (v' :: Q)) as HIn'
                  by eauto using in_cons.
              apply wfQueue in HIn' as wfMsg'.
              inverts wfMsg' as Hex' Hloc' HId' HBId'.
              constructors; hauto.
              split...
              ** apply HBId' in H0 as [? ?]...
              ** introv HLH'.
                 hauto.
                 +++ eapply HBId' in H0 as [? ?]...
                     rewrite H3 in H1...
                 +++ eapply HBId' in HLH'...
           -- unfolds wf_queue.
              inverts wfMsg as [t hasType] Hloc' HId' HBId'.
              exists t. repeat constructors...
           -- inv wfMsg. introv HIn. simpls.
              apply in_app_or in HIn.
              inv HIn... simpls. inv H6...
              contradiction.
           -- inv wfMsg. rewrite heapUpdate_length...
              introv HIn. simpls.
              apply in_app_or in HIn.
              inv HIn... simpls. contradiction.
           -- inverts wfMsg as Hex' Hloc' HId' HBId'.
              introv HIn. simpls.
              apply in_app_or in HIn.
              inv HIn; try contradiction...
              hauto.
              splits...
              introv HLH'.
              eapply HBId' in H0 as [? ?]...
              rewrite H3 in H1...
        ++ SSCase "id <> id0".
           destruct_actor a.
           apply wfActors in Hlookup as wfActor...
           inverts wfActor as Hthis wfQueue Hex Hloc HId HBId.
           constructors; hauto.
           -- unfolds wf_queue.
              introv HIn.
              apply wfQueue in HIn as wfMsg.
              inverts wfMsg as Hex' Hloc' HId' HBId'.
              constructors; hauto.
              split...
              ** apply HBId' in H0 as [? ?]...
              ** introv HLH'. hauto.
                 +++ unfolds LH.
                 eapply HBId' in H0 as [? ?]...
                 rewrite H3 in H1...
                 +++ eapply HBId' in H0 as [? ?]...
        -- split...
           ** eapply HBId in H0 as [? ?]...
           ** introv HLH'. hauto.
              +++ eapply HBId in H0 as [? ?]...
                 rewrite H3 in H1...
              +++ eapply HBId in H0 as [? ?]...
    - introv HLH'. unfolds LH.
      hauto.
      apply Hfresh with (id := id0).
      rewrite H3...
  + Case "EvalActorRun".
    assert (wf_actor H (l, L, Q, e)) as wfActor...
    inverts wfActor as Hthis wfQueue (t & hasType) Hloc HId HBId.
    assert (wf_heap H') as wfH'.
      eapply wf_heap_preservation...
      constructors...
    constructors.
    - assert (forall id1 id2 L1 L2,
                 id1 <> id2 ->
                 LH H' id1 = Some L1 ->
                 LH H' id2 = Some L2 ->
                 (forall l : loc, In l L1 -> ~ In l L2)) as Hdisj'
          by (inverts wfH' as (? & ?); eauto).
      eapply wf_heap_heapUpdate; try omega...
      assert (wf_actor H' (l, L', Q', e'')) as wfActor
          by (inverts wfH' as [_ ?]; eauto).
      eapply type_preservation in hasType...
      constructors...
      * inv wfActor...
      * eapply wf_queue_preservation...
      * eapply actor_locs_preservation...
        unfolds LH. crush.
      * eapply actor_ids_preservation...
      * eapply actor_bids_preservation...
        unfolds LH. crush.
    - introv HLH'. rewrite Forall_forall. introv HIn.
      unfolds LH. hauto.
      * eapply fresh_preservation with (id' := id0) (L := L0) in H4...
        rewrite Forall_forall in H4...
        unfolds. rewrite H6...
      * eapply fresh_preservation in H4...
        rewrite Forall_forall in H4...
Qed.