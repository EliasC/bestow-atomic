Require Export Static.

Require Import SyntaxProp.
Require Import MapProp.
Require Import Shared.

Lemma hasType_ctx :
  forall Gamma e t ctx,
    is_econtext ctx ->
    Gamma |- ctx e \in t ->
    exists t', Gamma |- e \in t'.
Proof with eauto.
  introv Hctx hasType.
  inv Hctx; inv hasType...
Qed.

Lemma free_in_env :
  forall Gamma x e t,
   In x (freeVars e) ->
   Gamma |- e \in t ->
   exists t', Gamma x = Some t'.
Proof with eauto.
  introv HIn hasType. gen t. gen Gamma.
  expr_cases(induction e) Case; intros;
    simpls; try inv HIn; inv hasType...
  + inv H.
  + apply in_app_or in HIn. inv HIn...
  + apply in_app_or in HIn. inv HIn...
    destruct (id_eq_dec x v).
    - subst. assert (~ In v (remove Nat.eq_dec v (freeVars e2))).
      eapply remove_in_eq... contradiction.
    - eapply remove_in in H...
      eapply IHe2 with (Gamma := extend (activeEnv Gamma) v TPas) in H as [t' Heq]...
      unfold extend in Heq. case_if...
      unfold activeEnv in Heq.
      destruct (Gamma x). case_if... inv Heq.
  + destruct (id_eq_dec x v).
    - subst. assert (~ In v (remove Nat.eq_dec v (freeVars e))).
      eapply remove_in_eq... contradiction.
    - eapply remove_in in HIn...
      eapply IHe with (Gamma := extend Gamma v t) in bodyHasType as [t' Heq]...
      unfold extend in Heq. case_if...
Qed.

Lemma hasType_closed :
  forall e t,
    empty |- e \in t ->
    freeVars e = nil.
Proof with eauto.
  introv hasType.
  assert (forall x, In x (freeVars e) -> exists T' : ty, empty x = Some T') as Hex.
    intros. eapply free_in_env...
  assert (forall x, ~ In x (freeVars e)) as HnIn.
    introv HIn. apply Hex in HIn as [contra].
    inv H.
  destruct (freeVars e)...
  assert (In v (v :: l)) as HIn
      by (constructors; eauto)...
  contradict HIn...
Qed.

Lemma hasType_subsumption :
  forall Gamma Gamma' e t,
    Gamma |- e \in t ->
    (forall x, In x (freeVars e) -> Gamma x = Gamma' x) ->
    Gamma' |- e \in t.
Proof with eauto using hasType.
  introv hasType Hsub. gen Gamma'.
  hasType_cases(induction hasType) Case;
    intros; simpls...
  + constructors...
    inv Hlookup... symmetry...
  + constructors...
  + constructors...
  + constructors...
    eapply IHhasType...
    intros. case_extend.
    apply Hsub...
    apply remove_in_neq...
  + assert (forall x : var, In x (freeVars e1) -> Gamma x = Gamma' x).
      introv HIn. apply Hsub. apply in_app_iff...
    assert (forall x : var, In x (freeVars e2) -> Gamma x = Gamma' x).
      introv HIn. apply Hsub. apply in_app_iff...
    constructors...
  + constructors...
    - eapply IHhasType1...
      intros.
      apply Hsub...
      apply in_app_iff...
    - eapply IHhasType2...
      intros. case_extend.
      assert (Gamma x0 = Gamma' x0) as Heq.
        apply Hsub. apply in_app_iff.
        right. apply remove_in_neq...
      unfold activeEnv.
      rewrite Heq...
Qed.

Corollary hasType_flip :
  forall Gamma x y e t t1 t2,
    extend (extend Gamma x t1) y t2 |- e \in t ->
    x <> y ->
    extend (extend Gamma y t2) x t1 |- e \in t.
Proof with eauto using hasType_subsumption.
  introv hasType Hneq.
  eapply hasType_subsumption
  with (Gamma := (extend (extend Gamma x t1) y t2))...
Qed.

Corollary hasType_shadow :
  forall Gamma x y e t t1 t2,
    extend (extend Gamma x t1) y t2 |- e \in t ->
    x = y ->
    extend Gamma y t2 |- e \in t.
Proof with eauto with env.
  introv hasType Hneq.
  eapply hasType_subsumption
  with (Gamma' := extend Gamma y t2)
  in hasType; eauto 2 with env.
Qed.

Corollary hasType_empty :
  forall Gamma e t,
    empty |- e \in t ->
    Gamma |- e \in t.
Proof with eauto.
  introv hasType.
  eapply hasType_subsumption
  with (Gamma' := Gamma)...
  introv HIn. apply hasType_closed in hasType...
  rewrite hasType in *. inv HIn.
Qed.

Lemma freeLocs_active_val :
  forall Gamma v t,
    Gamma |- v \in t ->
    is_active t = true ->
    is_val v ->
    freeLocs v = nil.
Proof with eauto.
  introv hasType Hact Hval.
  unfolds is_active.
  inv Hval; inv hasType; inv Hact...
Qed.

Lemma hasType_subst :
  forall Gamma e x v t1 t2,
    extend Gamma x t2 |- e \in t1 ->
    empty |- v \in t2 ->
    is_val v ->
    Gamma |- subst x v e \in t1.
Proof with eauto using hasType, hasType_empty, hasType_flip, hasType_shadow with env.
  introv hasType vHasType Hval.
  gen vHasType. gen v. gen t1. gen t2. gen x. gen Gamma.
  expr_cases(induction e) Case;
    intros; inv hasType; simpl...
  + case_if...
    subst. simpl_extend_hyp...
    inv Hlookup...
  + case_if.
    - subst. constructors...
      eapply hasType_subsumption...
      introv HIn. case_extend...
      unfold activeEnv. case_if...
    - constructors...
      * eapply IHe2... eapply hasType_flip...
        eapply hasType_subsumption...
        introv HIn.
        case_extend.
        ++ unfold activeEnv.
           cases_if. cases_if...
           eapply free_in_env in HIn as [t Heq]...
           rewrite extend_neq in Heq...
           unfolds activeEnv. rewrite extend_eq in Heq...
           case_if...
        ++ unfold activeEnv.
           cases_if. destruct (Gamma x0)...
      * assert (Halt : {In x (freeVars e2)} + {~ In x (freeVars e2)})
            by (apply in_dec; apply id_eq_dec).
        inv Halt as [HIn | HnIn].
        ++ eapply free_in_env in HIn as [t Heq]...
           rewrite extend_neq in Heq...
           unfolds activeEnv. rewrite extend_eq in Heq...
           case_if...
           assert (freeLocs v0 = nil)
               by eauto using freeLocs_active_val.
           apply freeLocs_subst...
        ++ rewrite subst_not_in...
  + case_if...
Qed.
